ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"UART_1.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	UART_1_initVar
  18              		.bss
  19              		.type	UART_1_initVar, %object
  20              		.size	UART_1_initVar, 1
  21              	UART_1_initVar:
  22 0000 00       		.space	1
  23              		.section	.text.UART_1_Start,"ax",%progbits
  24              		.align	2
  25              		.global	UART_1_Start
  26              		.code	16
  27              		.thumb_func
  28              		.type	UART_1_Start, %function
  29              	UART_1_Start:
  30              	.LFB0:
  31              		.file 1 ".\\Generated_Source\\PSoC4\\UART_1.c"
   1:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/UART_1.c **** * File Name: UART_1.c
   3:.\Generated_Source\PSoC4/UART_1.c **** * Version 2.30
   4:.\Generated_Source\PSoC4/UART_1.c **** *
   5:.\Generated_Source\PSoC4/UART_1.c **** * Description:
   6:.\Generated_Source\PSoC4/UART_1.c **** *  This file provides all API functionality of the UART component
   7:.\Generated_Source\PSoC4/UART_1.c **** *
   8:.\Generated_Source\PSoC4/UART_1.c **** * Note:
   9:.\Generated_Source\PSoC4/UART_1.c **** *
  10:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  11:.\Generated_Source\PSoC4/UART_1.c **** * Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
  12:.\Generated_Source\PSoC4/UART_1.c **** * You may use this file only in accordance with the license, terms, conditions,
  13:.\Generated_Source\PSoC4/UART_1.c **** * disclaimers, and limitations in the end user license agreement accompanying
  14:.\Generated_Source\PSoC4/UART_1.c **** * the software package with which this file was provided.
  15:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  16:.\Generated_Source\PSoC4/UART_1.c **** 
  17:.\Generated_Source\PSoC4/UART_1.c **** #include "UART_1.h"
  18:.\Generated_Source\PSoC4/UART_1.c **** #include "CyLib.h"
  19:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_INTERNAL_CLOCK_USED)
  20:.\Generated_Source\PSoC4/UART_1.c ****     #include "UART_1_IntClock.h"
  21:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_INTERNAL_CLOCK_USED */
  22:.\Generated_Source\PSoC4/UART_1.c **** 
  23:.\Generated_Source\PSoC4/UART_1.c **** 
  24:.\Generated_Source\PSoC4/UART_1.c **** /***************************************
  25:.\Generated_Source\PSoC4/UART_1.c **** * Global data allocation
  26:.\Generated_Source\PSoC4/UART_1.c **** ***************************************/
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 2


  27:.\Generated_Source\PSoC4/UART_1.c **** 
  28:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_initVar = 0u;
  29:.\Generated_Source\PSoC4/UART_1.c **** #if( UART_1_TX_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
  30:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBuffer[UART_1_TXBUFFERSIZE];
  31:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_txBufferRead = 0u;
  32:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_txBufferWrite = 0u;
  33:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_TX_ENABLED */
  34:.\Generated_Source\PSoC4/UART_1.c **** #if( ( UART_1_RX_ENABLED || UART_1_HD_ENABLED ) && \
  35:.\Generated_Source\PSoC4/UART_1.c ****      (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
  36:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBuffer[UART_1_RXBUFFERSIZE];
  37:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferRead = 0u;
  38:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferWrite = 0u;
  39:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferLoopDetect = 0u;
  40:.\Generated_Source\PSoC4/UART_1.c ****     volatile uint8 UART_1_rxBufferOverflow = 0u;
  41:.\Generated_Source\PSoC4/UART_1.c ****     #if (UART_1_RXHW_ADDRESS_ENABLED)
  42:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressMode = UART_1_RXADDRESSMODE;
  43:.\Generated_Source\PSoC4/UART_1.c ****         volatile uint8 UART_1_rxAddressDetected = 0u;
  44:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End EnableHWAddress */
  45:.\Generated_Source\PSoC4/UART_1.c **** #endif /* End UART_1_RX_ENABLED */
  46:.\Generated_Source\PSoC4/UART_1.c **** 
  47:.\Generated_Source\PSoC4/UART_1.c **** 
  48:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  49:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Start
  50:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  51:.\Generated_Source\PSoC4/UART_1.c **** *
  52:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  53:.\Generated_Source\PSoC4/UART_1.c **** *  Initialize and Enable the UART component.
  54:.\Generated_Source\PSoC4/UART_1.c **** *  Enable the clock input to enable operation.
  55:.\Generated_Source\PSoC4/UART_1.c **** *
  56:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  57:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  58:.\Generated_Source\PSoC4/UART_1.c **** *
  59:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  60:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  61:.\Generated_Source\PSoC4/UART_1.c **** *
  62:.\Generated_Source\PSoC4/UART_1.c **** * Global variables:
  63:.\Generated_Source\PSoC4/UART_1.c **** *  The UART_1_intiVar variable is used to indicate initial
  64:.\Generated_Source\PSoC4/UART_1.c **** *  configuration of this component. The variable is initialized to zero (0u)
  65:.\Generated_Source\PSoC4/UART_1.c **** *  and set to one (1u) the first time UART_Start() is called. This allows for
  66:.\Generated_Source\PSoC4/UART_1.c **** *  component initialization without re-initialization in all subsequent calls
  67:.\Generated_Source\PSoC4/UART_1.c **** *  to the UART_1_Start() routine.
  68:.\Generated_Source\PSoC4/UART_1.c **** *
  69:.\Generated_Source\PSoC4/UART_1.c **** * Reentrant:
  70:.\Generated_Source\PSoC4/UART_1.c **** *  No.
  71:.\Generated_Source\PSoC4/UART_1.c **** *
  72:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
  73:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Start(void) 
  74:.\Generated_Source\PSoC4/UART_1.c **** {
  32              		.loc 1 74 0
  33              		.cfi_startproc
  34 0000 80B5     		push	{r7, lr}
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38 0002 00AF     		add	r7, sp, #0
  39              		.cfi_def_cfa_register 7
  75:.\Generated_Source\PSoC4/UART_1.c ****     /* If not Initialized then initialize all required hardware and software */
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 3


  76:.\Generated_Source\PSoC4/UART_1.c ****     if(UART_1_initVar == 0u)
  40              		.loc 1 76 0
  41 0004 064B     		ldr	r3, .L3
  42 0006 1B78     		ldrb	r3, [r3]
  43 0008 002B     		cmp	r3, #0
  44 000a 04D1     		bne	.L2
  77:.\Generated_Source\PSoC4/UART_1.c ****     {
  78:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_Init();
  45              		.loc 1 78 0
  46 000c FFF7FEFF 		bl	UART_1_Init
  79:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_initVar = 1u;
  47              		.loc 1 79 0
  48 0010 034B     		ldr	r3, .L3
  49 0012 0122     		mov	r2, #1
  50 0014 1A70     		strb	r2, [r3]
  51              	.L2:
  80:.\Generated_Source\PSoC4/UART_1.c ****     }
  81:.\Generated_Source\PSoC4/UART_1.c ****     UART_1_Enable();
  52              		.loc 1 81 0
  53 0016 FFF7FEFF 		bl	UART_1_Enable
  82:.\Generated_Source\PSoC4/UART_1.c **** }
  54              		.loc 1 82 0
  55 001a BD46     		mov	sp, r7
  56              		@ sp needed
  57 001c 80BD     		pop	{r7, pc}
  58              	.L4:
  59 001e C046     		.align	2
  60              	.L3:
  61 0020 00000000 		.word	UART_1_initVar
  62              		.cfi_endproc
  63              	.LFE0:
  64              		.size	UART_1_Start, .-UART_1_Start
  65              		.section	.text.UART_1_Init,"ax",%progbits
  66              		.align	2
  67              		.global	UART_1_Init
  68              		.code	16
  69              		.thumb_func
  70              		.type	UART_1_Init, %function
  71              	UART_1_Init:
  72              	.LFB1:
  83:.\Generated_Source\PSoC4/UART_1.c **** 
  84:.\Generated_Source\PSoC4/UART_1.c **** 
  85:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
  86:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Init
  87:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
  88:.\Generated_Source\PSoC4/UART_1.c **** *
  89:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
  90:.\Generated_Source\PSoC4/UART_1.c **** *  Initialize component's parameters to the parameters set by user in the
  91:.\Generated_Source\PSoC4/UART_1.c **** *  customizer of the component placed onto schematic. Usually called in
  92:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_Start().
  93:.\Generated_Source\PSoC4/UART_1.c **** *
  94:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
  95:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  96:.\Generated_Source\PSoC4/UART_1.c **** *
  97:.\Generated_Source\PSoC4/UART_1.c **** * Return:
  98:.\Generated_Source\PSoC4/UART_1.c **** *  None.
  99:.\Generated_Source\PSoC4/UART_1.c **** *
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 4


 100:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 101:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Init(void) 
 102:.\Generated_Source\PSoC4/UART_1.c **** {
  73              		.loc 1 102 0
  74              		.cfi_startproc
  75 0000 80B5     		push	{r7, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 7, -8
  78              		.cfi_offset 14, -4
  79 0002 00AF     		add	r7, sp, #0
  80              		.cfi_def_cfa_register 7
 103:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 104:.\Generated_Source\PSoC4/UART_1.c **** 
 105:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 106:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the RX Interrupt. */
 107:.\Generated_Source\PSoC4/UART_1.c ****             (void)CyIntSetVector(UART_1_RX_VECT_NUM, &UART_1_RXISR);
 108:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_RX_VECT_NUM, UART_1_RX_PRIOR_NUM);
 109:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 110:.\Generated_Source\PSoC4/UART_1.c **** 
 111:.\Generated_Source\PSoC4/UART_1.c ****         #if (UART_1_RXHW_ADDRESS_ENABLED)
 112:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddressMode(UART_1_RXAddressMode);
 113:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress1(UART_1_RXHWADDRESS1);
 114:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_SetRxAddress2(UART_1_RXHWADDRESS2);
 115:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 116:.\Generated_Source\PSoC4/UART_1.c **** 
 117:.\Generated_Source\PSoC4/UART_1.c ****         /* Init Count7 period */
 118:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_PERIOD_REG = UART_1_RXBITCTR_INIT;
 119:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial RX interrupt mask */
 120:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = UART_1_INIT_RX_INTERRUPTS_MASK;
 121:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 122:.\Generated_Source\PSoC4/UART_1.c **** 
 123:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 124:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 125:.\Generated_Source\PSoC4/UART_1.c ****             /* Set the TX Interrupt. */
 126:.\Generated_Source\PSoC4/UART_1.c ****             (void)CyIntSetVector(UART_1_TX_VECT_NUM, &UART_1_TXISR);
 127:.\Generated_Source\PSoC4/UART_1.c ****             CyIntSetPriority(UART_1_TX_VECT_NUM, UART_1_TX_PRIOR_NUM);
 128:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 129:.\Generated_Source\PSoC4/UART_1.c **** 
 130:.\Generated_Source\PSoC4/UART_1.c ****         /* Write Counter Value for TX Bit Clk Generator*/
 131:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXCLKGEN_DP)
 132:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKGEN_CTR_REG = UART_1_BIT_CENTER;
  81              		.loc 1 132 0
  82 0004 054B     		ldr	r3, .L6
  83 0006 0722     		mov	r2, #7
  84 0008 1A70     		strb	r2, [r3]
 133:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCLKTX_COMPLETE_REG = (UART_1_NUMBER_OF_DATA_BITS +
  85              		.loc 1 133 0
  86 000a 054B     		ldr	r3, .L6+4
  87 000c 4822     		mov	r2, #72
  88 000e 1A70     		strb	r2, [r3]
 134:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_COUNT;
 135:.\Generated_Source\PSoC4/UART_1.c ****         #else
 136:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_PERIOD_REG = ((UART_1_NUMBER_OF_DATA_BITS +
 137:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_NUMBER_OF_START_BIT) * UART_1_OVER_SAMPLE_8) - 1u;
 138:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 139:.\Generated_Source\PSoC4/UART_1.c **** 
 140:.\Generated_Source\PSoC4/UART_1.c ****         /* Configure the Initial TX interrupt mask */
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 5


 141:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 142:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_TX_STS_FIFO_EMPTY;
 143:.\Generated_Source\PSoC4/UART_1.c ****         #else
 144:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXSTATUS_MASK_REG = UART_1_INIT_TX_INTERRUPTS_MASK;
  89              		.loc 1 144 0
  90 0010 044B     		ldr	r3, .L6+8
  91 0012 0022     		mov	r2, #0
  92 0014 1A70     		strb	r2, [r3]
 145:.\Generated_Source\PSoC4/UART_1.c ****         #endif /*End UART_1_TX_INTERRUPT_ENABLED*/
 146:.\Generated_Source\PSoC4/UART_1.c **** 
 147:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 148:.\Generated_Source\PSoC4/UART_1.c **** 
 149:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_PARITY_TYPE_SW)  /* Write Parity to Control Register */
 150:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_WriteControlRegister( \
 151:.\Generated_Source\PSoC4/UART_1.c ****             (UART_1_ReadControlRegister() & (uint8)~UART_1_CTRL_PARITY_TYPE_MASK) | \
 152:.\Generated_Source\PSoC4/UART_1.c ****             (uint8)(UART_1_PARITY_TYPE << UART_1_CTRL_PARITY_TYPE0_SHIFT) );
 153:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_PARITY_TYPE_SW */
 154:.\Generated_Source\PSoC4/UART_1.c **** }
  93              		.loc 1 154 0
  94 0016 BD46     		mov	sp, r7
  95              		@ sp needed
  96 0018 80BD     		pop	{r7, pc}
  97              	.L7:
  98 001a C046     		.align	2
  99              	.L6:
 100 001c 21000F40 		.word	1074724897
 101 0020 31000F40 		.word	1074724913
 102 0024 80000F40 		.word	1074724992
 103              		.cfi_endproc
 104              	.LFE1:
 105              		.size	UART_1_Init, .-UART_1_Init
 106              		.section	.text.UART_1_Enable,"ax",%progbits
 107              		.align	2
 108              		.global	UART_1_Enable
 109              		.code	16
 110              		.thumb_func
 111              		.type	UART_1_Enable, %function
 112              	UART_1_Enable:
 113              	.LFB2:
 155:.\Generated_Source\PSoC4/UART_1.c **** 
 156:.\Generated_Source\PSoC4/UART_1.c **** 
 157:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 158:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Enable
 159:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 160:.\Generated_Source\PSoC4/UART_1.c **** *
 161:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 162:.\Generated_Source\PSoC4/UART_1.c **** *  Enables the UART block operation
 163:.\Generated_Source\PSoC4/UART_1.c **** *
 164:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 165:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 166:.\Generated_Source\PSoC4/UART_1.c **** *
 167:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 168:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 169:.\Generated_Source\PSoC4/UART_1.c **** *
 170:.\Generated_Source\PSoC4/UART_1.c **** * Global Variables:
 171:.\Generated_Source\PSoC4/UART_1.c **** *  UART_1_rxAddressDetected - set to initial state (0).
 172:.\Generated_Source\PSoC4/UART_1.c **** *
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 6


 173:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 174:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Enable(void) 
 175:.\Generated_Source\PSoC4/UART_1.c **** {
 114              		.loc 1 175 0
 115              		.cfi_startproc
 116 0000 90B5     		push	{r4, r7, lr}
 117              		.cfi_def_cfa_offset 12
 118              		.cfi_offset 4, -12
 119              		.cfi_offset 7, -8
 120              		.cfi_offset 14, -4
 121 0002 83B0     		sub	sp, sp, #12
 122              		.cfi_def_cfa_offset 24
 123 0004 00AF     		add	r7, sp, #0
 124              		.cfi_def_cfa_register 7
 176:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 177:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 125              		.loc 1 177 0
 126 0006 FC1D     		add	r4, r7, #7
 127 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 128 000c 031C     		mov	r3, r0
 129 000e 2370     		strb	r3, [r4]
 178:.\Generated_Source\PSoC4/UART_1.c **** 
 179:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 180:.\Generated_Source\PSoC4/UART_1.c ****         /*RX Counter (Count7) Enable */
 181:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 182:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the RX Interrupt. */
 183:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  |= UART_1_INT_ENABLE;
 184:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 185:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
 186:.\Generated_Source\PSoC4/UART_1.c ****             #if (UART_1_RXHW_ADDRESS_ENABLED)
 187:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxAddressDetected = 0u;
 188:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 189:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 190:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 191:.\Generated_Source\PSoC4/UART_1.c **** 
 192:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 193:.\Generated_Source\PSoC4/UART_1.c ****         /*TX Counter (DP/Count7) Enable */
 194:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 195:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG |= UART_1_CNTR_ENABLE;
 196:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 197:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the TX Interrupt. */
 198:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG |= UART_1_INT_ENABLE;
 130              		.loc 1 198 0
 131 0010 084B     		ldr	r3, .L9
 132 0012 084A     		ldr	r2, .L9
 133 0014 1278     		ldrb	r2, [r2]
 134 0016 D2B2     		uxtb	r2, r2
 135 0018 1021     		mov	r1, #16
 136 001a 0A43     		orr	r2, r1
 137 001c D2B2     		uxtb	r2, r2
 138 001e 1A70     		strb	r2, [r3]
 199:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 200:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 201:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED*/
 202:.\Generated_Source\PSoC4/UART_1.c ****      #endif /* End UART_1_TX_ENABLED */
 203:.\Generated_Source\PSoC4/UART_1.c **** 
 204:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 7


 205:.\Generated_Source\PSoC4/UART_1.c ****         /* Enable the clock. */
 206:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Start();
 139              		.loc 1 206 0
 140 0020 FFF7FEFF 		bl	UART_1_IntClock_Start
 207:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 208:.\Generated_Source\PSoC4/UART_1.c **** 
 209:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 141              		.loc 1 209 0
 142 0024 FB1D     		add	r3, r7, #7
 143 0026 1B78     		ldrb	r3, [r3]
 144 0028 181C     		mov	r0, r3
 145 002a FFF7FEFF 		bl	CyExitCriticalSection
 210:.\Generated_Source\PSoC4/UART_1.c **** }
 146              		.loc 1 210 0
 147 002e BD46     		mov	sp, r7
 148 0030 03B0     		add	sp, sp, #12
 149              		@ sp needed
 150 0032 90BD     		pop	{r4, r7, pc}
 151              	.L10:
 152              		.align	2
 153              	.L9:
 154 0034 90000F40 		.word	1074725008
 155              		.cfi_endproc
 156              	.LFE2:
 157              		.size	UART_1_Enable, .-UART_1_Enable
 158              		.section	.text.UART_1_Stop,"ax",%progbits
 159              		.align	2
 160              		.global	UART_1_Stop
 161              		.code	16
 162              		.thumb_func
 163              		.type	UART_1_Stop, %function
 164              	UART_1_Stop:
 165              	.LFB3:
 211:.\Generated_Source\PSoC4/UART_1.c **** 
 212:.\Generated_Source\PSoC4/UART_1.c **** 
 213:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 214:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_Stop
 215:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 216:.\Generated_Source\PSoC4/UART_1.c **** *
 217:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 218:.\Generated_Source\PSoC4/UART_1.c **** *  Disable the UART component
 219:.\Generated_Source\PSoC4/UART_1.c **** *
 220:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 221:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 222:.\Generated_Source\PSoC4/UART_1.c **** *
 223:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 224:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 225:.\Generated_Source\PSoC4/UART_1.c **** *
 226:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 227:.\Generated_Source\PSoC4/UART_1.c **** void UART_1_Stop(void) 
 228:.\Generated_Source\PSoC4/UART_1.c **** {
 166              		.loc 1 228 0
 167              		.cfi_startproc
 168 0000 90B5     		push	{r4, r7, lr}
 169              		.cfi_def_cfa_offset 12
 170              		.cfi_offset 4, -12
 171              		.cfi_offset 7, -8
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 8


 172              		.cfi_offset 14, -4
 173 0002 83B0     		sub	sp, sp, #12
 174              		.cfi_def_cfa_offset 24
 175 0004 00AF     		add	r7, sp, #0
 176              		.cfi_def_cfa_register 7
 229:.\Generated_Source\PSoC4/UART_1.c ****     uint8 enableInterrupts;
 230:.\Generated_Source\PSoC4/UART_1.c ****     enableInterrupts = CyEnterCriticalSection();
 177              		.loc 1 230 0
 178 0006 FC1D     		add	r4, r7, #7
 179 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 180 000c 031C     		mov	r3, r0
 181 000e 2370     		strb	r3, [r4]
 231:.\Generated_Source\PSoC4/UART_1.c **** 
 232:.\Generated_Source\PSoC4/UART_1.c ****     /* Write Bit Counter Disable */
 233:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 234:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 235:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 236:.\Generated_Source\PSoC4/UART_1.c **** 
 237:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 238:.\Generated_Source\PSoC4/UART_1.c ****         #if(!UART_1_TXCLKGEN_DP)
 239:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_TXBITCTR_CONTROL_REG &= (uint8)~UART_1_CNTR_ENABLE;
 240:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXCLKGEN_DP */
 241:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_TX_ENABLED */
 242:.\Generated_Source\PSoC4/UART_1.c **** 
 243:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_INTERNAL_CLOCK_USED)
 244:.\Generated_Source\PSoC4/UART_1.c ****         /* Disable the clock. */
 245:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_IntClock_Stop();
 182              		.loc 1 245 0
 183 0010 FFF7FEFF 		bl	UART_1_IntClock_Stop
 246:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_INTERNAL_CLOCK_USED */
 247:.\Generated_Source\PSoC4/UART_1.c **** 
 248:.\Generated_Source\PSoC4/UART_1.c ****     /* Disable internal interrupt component */
 249:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 250:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_ACTL_REG  &= (uint8)~UART_1_INT_ENABLE;
 251:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RX_INTERRUPT_ENABLED && (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH))
 252:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableRxInt();
 253:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 254:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_RX_ENABLED */
 255:.\Generated_Source\PSoC4/UART_1.c **** 
 256:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_ENABLED)
 257:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_ACTL_REG &= (uint8)~UART_1_INT_ENABLE;
 184              		.loc 1 257 0
 185 0014 074B     		ldr	r3, .L12
 186 0016 074A     		ldr	r2, .L12
 187 0018 1278     		ldrb	r2, [r2]
 188 001a D2B2     		uxtb	r2, r2
 189 001c 1021     		mov	r1, #16
 190 001e 8A43     		bic	r2, r1
 191 0020 D2B2     		uxtb	r2, r2
 192 0022 1A70     		strb	r2, [r3]
 258:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TX_INTERRUPT_ENABLED && (UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH))
 259:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_DisableTxInt();
 260:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TX_INTERRUPT_ENABLED */
 261:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_TX_ENABLED */
 262:.\Generated_Source\PSoC4/UART_1.c **** 
 263:.\Generated_Source\PSoC4/UART_1.c ****     CyExitCriticalSection(enableInterrupts);
 193              		.loc 1 263 0
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 9


 194 0024 FB1D     		add	r3, r7, #7
 195 0026 1B78     		ldrb	r3, [r3]
 196 0028 181C     		mov	r0, r3
 197 002a FFF7FEFF 		bl	CyExitCriticalSection
 264:.\Generated_Source\PSoC4/UART_1.c **** }
 198              		.loc 1 264 0
 199 002e BD46     		mov	sp, r7
 200 0030 03B0     		add	sp, sp, #12
 201              		@ sp needed
 202 0032 90BD     		pop	{r4, r7, pc}
 203              	.L13:
 204              		.align	2
 205              	.L12:
 206 0034 90000F40 		.word	1074725008
 207              		.cfi_endproc
 208              	.LFE3:
 209              		.size	UART_1_Stop, .-UART_1_Stop
 210              		.section	.text.UART_1_ReadControlRegister,"ax",%progbits
 211              		.align	2
 212              		.global	UART_1_ReadControlRegister
 213              		.code	16
 214              		.thumb_func
 215              		.type	UART_1_ReadControlRegister, %function
 216              	UART_1_ReadControlRegister:
 217              	.LFB4:
 265:.\Generated_Source\PSoC4/UART_1.c **** 
 266:.\Generated_Source\PSoC4/UART_1.c **** 
 267:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 268:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_ReadControlRegister
 269:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 270:.\Generated_Source\PSoC4/UART_1.c **** *
 271:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 272:.\Generated_Source\PSoC4/UART_1.c **** *  Read the current state of the control register
 273:.\Generated_Source\PSoC4/UART_1.c **** *
 274:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 275:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 276:.\Generated_Source\PSoC4/UART_1.c **** *
 277:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 278:.\Generated_Source\PSoC4/UART_1.c **** *  Current state of the control register.
 279:.\Generated_Source\PSoC4/UART_1.c **** *
 280:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 281:.\Generated_Source\PSoC4/UART_1.c **** uint8 UART_1_ReadControlRegister(void) 
 282:.\Generated_Source\PSoC4/UART_1.c **** {
 218              		.loc 1 282 0
 219              		.cfi_startproc
 220 0000 80B5     		push	{r7, lr}
 221              		.cfi_def_cfa_offset 8
 222              		.cfi_offset 7, -8
 223              		.cfi_offset 14, -4
 224 0002 00AF     		add	r7, sp, #0
 225              		.cfi_def_cfa_register 7
 283:.\Generated_Source\PSoC4/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 284:.\Generated_Source\PSoC4/UART_1.c ****         return(0u);
 226              		.loc 1 284 0
 227 0004 0023     		mov	r3, #0
 285:.\Generated_Source\PSoC4/UART_1.c ****     #else
 286:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_CONTROL_REG);
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 10


 287:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 288:.\Generated_Source\PSoC4/UART_1.c **** }
 228              		.loc 1 288 0
 229 0006 181C     		mov	r0, r3
 230 0008 BD46     		mov	sp, r7
 231              		@ sp needed
 232 000a 80BD     		pop	{r7, pc}
 233              		.cfi_endproc
 234              	.LFE4:
 235              		.size	UART_1_ReadControlRegister, .-UART_1_ReadControlRegister
 236              		.section	.text.UART_1_WriteControlRegister,"ax",%progbits
 237              		.align	2
 238              		.global	UART_1_WriteControlRegister
 239              		.code	16
 240              		.thumb_func
 241              		.type	UART_1_WriteControlRegister, %function
 242              	UART_1_WriteControlRegister:
 243              	.LFB5:
 289:.\Generated_Source\PSoC4/UART_1.c **** 
 290:.\Generated_Source\PSoC4/UART_1.c **** 
 291:.\Generated_Source\PSoC4/UART_1.c **** /*******************************************************************************
 292:.\Generated_Source\PSoC4/UART_1.c **** * Function Name: UART_1_WriteControlRegister
 293:.\Generated_Source\PSoC4/UART_1.c **** ********************************************************************************
 294:.\Generated_Source\PSoC4/UART_1.c **** *
 295:.\Generated_Source\PSoC4/UART_1.c **** * Summary:
 296:.\Generated_Source\PSoC4/UART_1.c **** *  Writes an 8-bit value into the control register
 297:.\Generated_Source\PSoC4/UART_1.c **** *
 298:.\Generated_Source\PSoC4/UART_1.c **** * Parameters:
 299:.\Generated_Source\PSoC4/UART_1.c **** *  control:  control register value
 300:.\Generated_Source\PSoC4/UART_1.c **** *
 301:.\Generated_Source\PSoC4/UART_1.c **** * Return:
 302:.\Generated_Source\PSoC4/UART_1.c **** *  None.
 303:.\Generated_Source\PSoC4/UART_1.c **** *
 304:.\Generated_Source\PSoC4/UART_1.c **** *******************************************************************************/
 305:.\Generated_Source\PSoC4/UART_1.c **** void  UART_1_WriteControlRegister(uint8 control) 
 306:.\Generated_Source\PSoC4/UART_1.c **** {
 244              		.loc 1 306 0
 245              		.cfi_startproc
 246 0000 80B5     		push	{r7, lr}
 247              		.cfi_def_cfa_offset 8
 248              		.cfi_offset 7, -8
 249              		.cfi_offset 14, -4
 250 0002 82B0     		sub	sp, sp, #8
 251              		.cfi_def_cfa_offset 16
 252 0004 00AF     		add	r7, sp, #0
 253              		.cfi_def_cfa_register 7
 254 0006 021C     		mov	r2, r0
 255 0008 FB1D     		add	r3, r7, #7
 256 000a 1A70     		strb	r2, [r3]
 307:.\Generated_Source\PSoC4/UART_1.c ****     #if( UART_1_CONTROL_REG_REMOVED )
 308:.\Generated_Source\PSoC4/UART_1.c ****         if(control != 0u) { }      /* release compiler warning */
 309:.\Generated_Source\PSoC4/UART_1.c ****     #else
 310:.\Generated_Source\PSoC4/UART_1.c ****        UART_1_CONTROL_REG = control;
 311:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* End UART_1_CONTROL_REG_REMOVED */
 312:.\Generated_Source\PSoC4/UART_1.c **** }
 257              		.loc 1 312 0
 258 000c BD46     		mov	sp, r7
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 11


 259 000e 02B0     		add	sp, sp, #8
 260              		@ sp needed
 261 0010 80BD     		pop	{r7, pc}
 262              		.cfi_endproc
 263              	.LFE5:
 264              		.size	UART_1_WriteControlRegister, .-UART_1_WriteControlRegister
 265 0012 C046     		.section	.text.UART_1_SetTxInterruptMode,"ax",%progbits
 266              		.align	2
 267              		.global	UART_1_SetTxInterruptMode
 268              		.code	16
 269              		.thumb_func
 270              		.type	UART_1_SetTxInterruptMode, %function
 271              	UART_1_SetTxInterruptMode:
 272              	.LFB6:
 313:.\Generated_Source\PSoC4/UART_1.c **** 
 314:.\Generated_Source\PSoC4/UART_1.c **** 
 315:.\Generated_Source\PSoC4/UART_1.c **** #if(UART_1_RX_ENABLED || UART_1_HD_ENABLED)
 316:.\Generated_Source\PSoC4/UART_1.c **** 
 317:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_RX_INTERRUPT_ENABLED)
 318:.\Generated_Source\PSoC4/UART_1.c **** 
 319:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 320:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_EnableRxInt
 321:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 322:.\Generated_Source\PSoC4/UART_1.c ****         *
 323:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 324:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable RX interrupt generation
 325:.\Generated_Source\PSoC4/UART_1.c ****         *
 326:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 327:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 328:.\Generated_Source\PSoC4/UART_1.c ****         *
 329:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 330:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 331:.\Generated_Source\PSoC4/UART_1.c ****         *
 332:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 333:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 334:.\Generated_Source\PSoC4/UART_1.c ****         *
 335:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 336:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_EnableRxInt(void) 
 337:.\Generated_Source\PSoC4/UART_1.c ****         {
 338:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_RX_VECT_NUM);
 339:.\Generated_Source\PSoC4/UART_1.c ****         }
 340:.\Generated_Source\PSoC4/UART_1.c **** 
 341:.\Generated_Source\PSoC4/UART_1.c **** 
 342:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 343:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_DisableRxInt
 344:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 345:.\Generated_Source\PSoC4/UART_1.c ****         *
 346:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 347:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable RX interrupt generation
 348:.\Generated_Source\PSoC4/UART_1.c ****         *
 349:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 350:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 351:.\Generated_Source\PSoC4/UART_1.c ****         *
 352:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 353:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 354:.\Generated_Source\PSoC4/UART_1.c ****         *
 355:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 12


 356:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 357:.\Generated_Source\PSoC4/UART_1.c ****         *
 358:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 359:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_DisableRxInt(void) 
 360:.\Generated_Source\PSoC4/UART_1.c ****         {
 361:.\Generated_Source\PSoC4/UART_1.c ****             CyIntDisable(UART_1_RX_VECT_NUM);
 362:.\Generated_Source\PSoC4/UART_1.c ****         }
 363:.\Generated_Source\PSoC4/UART_1.c **** 
 364:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_RX_INTERRUPT_ENABLED */
 365:.\Generated_Source\PSoC4/UART_1.c **** 
 366:.\Generated_Source\PSoC4/UART_1.c **** 
 367:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 368:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxInterruptMode
 369:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 370:.\Generated_Source\PSoC4/UART_1.c ****     *
 371:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 372:.\Generated_Source\PSoC4/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 373:.\Generated_Source\PSoC4/UART_1.c ****     *
 374:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 375:.\Generated_Source\PSoC4/UART_1.c ****     *  IntSrc:  An or'd combination of the desired status bit masks (defined in
 376:.\Generated_Source\PSoC4/UART_1.c ****     *           the header file)
 377:.\Generated_Source\PSoC4/UART_1.c ****     *
 378:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 379:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 380:.\Generated_Source\PSoC4/UART_1.c ****     *
 381:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 382:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 383:.\Generated_Source\PSoC4/UART_1.c ****     *
 384:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 385:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxInterruptMode(uint8 intSrc) 
 386:.\Generated_Source\PSoC4/UART_1.c ****     {
 387:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXSTATUS_MASK_REG  = intSrc;
 388:.\Generated_Source\PSoC4/UART_1.c ****     }
 389:.\Generated_Source\PSoC4/UART_1.c **** 
 390:.\Generated_Source\PSoC4/UART_1.c **** 
 391:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 392:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxData
 393:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 394:.\Generated_Source\PSoC4/UART_1.c ****     *
 395:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 396:.\Generated_Source\PSoC4/UART_1.c ****     *  Returns data in RX Data register without checking status register to
 397:.\Generated_Source\PSoC4/UART_1.c ****     *  determine if data is valid
 398:.\Generated_Source\PSoC4/UART_1.c ****     *
 399:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 400:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 401:.\Generated_Source\PSoC4/UART_1.c ****     *
 402:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 403:.\Generated_Source\PSoC4/UART_1.c ****     *  Received data from RX register
 404:.\Generated_Source\PSoC4/UART_1.c ****     *
 405:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 406:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 407:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 408:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 409:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 410:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 411:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 412:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 13


 413:.\Generated_Source\PSoC4/UART_1.c ****     *
 414:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 415:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 416:.\Generated_Source\PSoC4/UART_1.c ****     *
 417:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 418:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxData(void) 
 419:.\Generated_Source\PSoC4/UART_1.c ****     {
 420:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData;
 421:.\Generated_Source\PSoC4/UART_1.c **** 
 422:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 423:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferRead;
 424:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferWrite;
 425:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 426:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 427:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 428:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 429:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 430:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
 431:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 432:.\Generated_Source\PSoC4/UART_1.c **** 
 433:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 434:.\Generated_Source\PSoC4/UART_1.c ****             {
 435:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 436:.\Generated_Source\PSoC4/UART_1.c ****                 loc_rxBufferRead++;
 437:.\Generated_Source\PSoC4/UART_1.c **** 
 438:.\Generated_Source\PSoC4/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 439:.\Generated_Source\PSoC4/UART_1.c ****                 {
 440:.\Generated_Source\PSoC4/UART_1.c ****                     loc_rxBufferRead = 0u;
 441:.\Generated_Source\PSoC4/UART_1.c ****                 }
 442:.\Generated_Source\PSoC4/UART_1.c ****                 /* Update the real pointer */
 443:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 444:.\Generated_Source\PSoC4/UART_1.c **** 
 445:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect != 0u )
 446:.\Generated_Source\PSoC4/UART_1.c ****                 {
 447:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 448:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) && \
 449:.\Generated_Source\PSoC4/UART_1.c ****                          (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 450:.\Generated_Source\PSoC4/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 451:.\Generated_Source\PSoC4/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 452:.\Generated_Source\PSoC4/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 453:.\Generated_Source\PSoC4/UART_1.c ****                             {   /* In Half duplex mode return RX mask only in RX
 454:.\Generated_Source\PSoC4/UART_1.c ****                                 *  configuration set, otherwise
 455:.\Generated_Source\PSoC4/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
 456:.\Generated_Source\PSoC4/UART_1.c ****                                 */
 457:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 458:.\Generated_Source\PSoC4/UART_1.c ****                             }
 459:.\Generated_Source\PSoC4/UART_1.c ****                         #else
 460:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 461:.\Generated_Source\PSoC4/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 462:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 463:.\Generated_Source\PSoC4/UART_1.c ****                 }
 464:.\Generated_Source\PSoC4/UART_1.c ****             }
 465:.\Generated_Source\PSoC4/UART_1.c ****             else
 466:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 467:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 468:.\Generated_Source\PSoC4/UART_1.c ****             }
 469:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 14


 470:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 471:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 472:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 473:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 474:.\Generated_Source\PSoC4/UART_1.c **** 
 475:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 476:.\Generated_Source\PSoC4/UART_1.c **** 
 477:.\Generated_Source\PSoC4/UART_1.c ****             /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit*/
 478:.\Generated_Source\PSoC4/UART_1.c ****             rxData = UART_1_RXDATA_REG;
 479:.\Generated_Source\PSoC4/UART_1.c **** 
 480:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 481:.\Generated_Source\PSoC4/UART_1.c **** 
 482:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 483:.\Generated_Source\PSoC4/UART_1.c ****     }
 484:.\Generated_Source\PSoC4/UART_1.c **** 
 485:.\Generated_Source\PSoC4/UART_1.c **** 
 486:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 487:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadRxStatus
 488:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 489:.\Generated_Source\PSoC4/UART_1.c ****     *
 490:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 491:.\Generated_Source\PSoC4/UART_1.c ****     *  Read the current state of the status register
 492:.\Generated_Source\PSoC4/UART_1.c ****     *  And detect software buffer overflow.
 493:.\Generated_Source\PSoC4/UART_1.c ****     *
 494:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 495:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 496:.\Generated_Source\PSoC4/UART_1.c ****     *
 497:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 498:.\Generated_Source\PSoC4/UART_1.c ****     *  Current state of the status register.
 499:.\Generated_Source\PSoC4/UART_1.c ****     *
 500:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 501:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - used to indicate overload condition.
 502:.\Generated_Source\PSoC4/UART_1.c ****     *   It set to one in RX interrupt when there isn?t free space in
 503:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_rxBufferRead to write new data. This condition returned
 504:.\Generated_Source\PSoC4/UART_1.c ****     *   and cleared to zero by this API as an
 505:.\Generated_Source\PSoC4/UART_1.c ****     *   UART_1_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 506:.\Generated_Source\PSoC4/UART_1.c ****     *   bits.
 507:.\Generated_Source\PSoC4/UART_1.c ****     *
 508:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 509:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadRxStatus(void) 
 510:.\Generated_Source\PSoC4/UART_1.c ****     {
 511:.\Generated_Source\PSoC4/UART_1.c ****         uint8 status;
 512:.\Generated_Source\PSoC4/UART_1.c **** 
 513:.\Generated_Source\PSoC4/UART_1.c ****         status = UART_1_RXSTATUS_REG & UART_1_RX_HW_MASK;
 514:.\Generated_Source\PSoC4/UART_1.c **** 
 515:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 516:.\Generated_Source\PSoC4/UART_1.c ****             if( UART_1_rxBufferOverflow != 0u )
 517:.\Generated_Source\PSoC4/UART_1.c ****             {
 518:.\Generated_Source\PSoC4/UART_1.c ****                 status |= UART_1_RX_STS_SOFT_BUFF_OVER;
 519:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferOverflow = 0u;
 520:.\Generated_Source\PSoC4/UART_1.c ****             }
 521:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE */
 522:.\Generated_Source\PSoC4/UART_1.c **** 
 523:.\Generated_Source\PSoC4/UART_1.c ****         return(status);
 524:.\Generated_Source\PSoC4/UART_1.c ****     }
 525:.\Generated_Source\PSoC4/UART_1.c **** 
 526:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 15


 527:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 528:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetChar
 529:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 530:.\Generated_Source\PSoC4/UART_1.c ****     *
 531:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 532:.\Generated_Source\PSoC4/UART_1.c ****     *  Reads UART RX buffer immediately, if data is not available or an error
 533:.\Generated_Source\PSoC4/UART_1.c ****     *  condition exists, zero is returned; otherwise, character is read and
 534:.\Generated_Source\PSoC4/UART_1.c ****     *  returned.
 535:.\Generated_Source\PSoC4/UART_1.c ****     *
 536:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 537:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 538:.\Generated_Source\PSoC4/UART_1.c ****     *
 539:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 540:.\Generated_Source\PSoC4/UART_1.c ****     *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 541:.\Generated_Source\PSoC4/UART_1.c ****     *  A returned zero signifies an error condition or no data available.
 542:.\Generated_Source\PSoC4/UART_1.c ****     *
 543:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 544:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBuffer - RAM buffer pointer for save received data.
 545:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cyclic index for write to rxBuffer,
 546:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify new data.
 547:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cyclic index for read from rxBuffer,
 548:.\Generated_Source\PSoC4/UART_1.c ****     *     incremented after each byte has been read from buffer.
 549:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - creared if loop condition was detected
 550:.\Generated_Source\PSoC4/UART_1.c ****     *     in RX ISR.
 551:.\Generated_Source\PSoC4/UART_1.c ****     *
 552:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 553:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 554:.\Generated_Source\PSoC4/UART_1.c ****     *
 555:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 556:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetChar(void) 
 557:.\Generated_Source\PSoC4/UART_1.c ****     {
 558:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxData = 0u;
 559:.\Generated_Source\PSoC4/UART_1.c ****         uint8 rxStatus;
 560:.\Generated_Source\PSoC4/UART_1.c **** 
 561:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 562:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferRead;
 563:.\Generated_Source\PSoC4/UART_1.c ****             uint8 loc_rxBufferWrite;
 564:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 565:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 566:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 567:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 568:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 569:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferRead = UART_1_rxBufferRead;
 570:.\Generated_Source\PSoC4/UART_1.c ****             loc_rxBufferWrite = UART_1_rxBufferWrite;
 571:.\Generated_Source\PSoC4/UART_1.c **** 
 572:.\Generated_Source\PSoC4/UART_1.c ****             if( (UART_1_rxBufferLoopDetect != 0u) || (loc_rxBufferRead != loc_rxBufferWrite) )
 573:.\Generated_Source\PSoC4/UART_1.c ****             {
 574:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_rxBuffer[loc_rxBufferRead];
 575:.\Generated_Source\PSoC4/UART_1.c ****                 loc_rxBufferRead++;
 576:.\Generated_Source\PSoC4/UART_1.c ****                 if(loc_rxBufferRead >= UART_1_RXBUFFERSIZE)
 577:.\Generated_Source\PSoC4/UART_1.c ****                 {
 578:.\Generated_Source\PSoC4/UART_1.c ****                     loc_rxBufferRead = 0u;
 579:.\Generated_Source\PSoC4/UART_1.c ****                 }
 580:.\Generated_Source\PSoC4/UART_1.c ****                 /* Update the real pointer */
 581:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_rxBufferRead = loc_rxBufferRead;
 582:.\Generated_Source\PSoC4/UART_1.c **** 
 583:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u )
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 16


 584:.\Generated_Source\PSoC4/UART_1.c ****                 {
 585:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxBufferLoopDetect = 0u;
 586:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_RX_INTERRUPT_ENABLED) && (UART_1_FLOW_CONTROL != 0u) )
 587:.\Generated_Source\PSoC4/UART_1.c ****                         /* When Hardware Flow Control selected - return RX mask */
 588:.\Generated_Source\PSoC4/UART_1.c ****                         #if( UART_1_HD_ENABLED )
 589:.\Generated_Source\PSoC4/UART_1.c ****                             if((UART_1_CONTROL_REG & UART_1_CTRL_HD_SEND) == 0u)
 590:.\Generated_Source\PSoC4/UART_1.c ****                             {   /* In Half duplex mode return RX mask only if
 591:.\Generated_Source\PSoC4/UART_1.c ****                                 *  RX configuration set, otherwise
 592:.\Generated_Source\PSoC4/UART_1.c ****                                 *  mask will be returned in LoadRxConfig() API.
 593:.\Generated_Source\PSoC4/UART_1.c ****                                 */
 594:.\Generated_Source\PSoC4/UART_1.c ****                                 UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 595:.\Generated_Source\PSoC4/UART_1.c ****                             }
 596:.\Generated_Source\PSoC4/UART_1.c ****                         #else
 597:.\Generated_Source\PSoC4/UART_1.c ****                             UART_1_RXSTATUS_MASK_REG  |= UART_1_RX_STS_FIFO_NOTEMPTY;
 598:.\Generated_Source\PSoC4/UART_1.c ****                         #endif /* end UART_1_HD_ENABLED */
 599:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* UART_1_RX_INTERRUPT_ENABLED and Hardware flow control*/
 600:.\Generated_Source\PSoC4/UART_1.c ****                 }
 601:.\Generated_Source\PSoC4/UART_1.c **** 
 602:.\Generated_Source\PSoC4/UART_1.c ****             }
 603:.\Generated_Source\PSoC4/UART_1.c ****             else
 604:.\Generated_Source\PSoC4/UART_1.c ****             {   rxStatus = UART_1_RXSTATUS_REG;
 605:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 606:.\Generated_Source\PSoC4/UART_1.c ****                 {   /* Read received data from FIFO*/
 607:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = UART_1_RXDATA_REG;
 608:.\Generated_Source\PSoC4/UART_1.c ****                     /*Check status on error*/
 609:.\Generated_Source\PSoC4/UART_1.c ****                     if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 610:.\Generated_Source\PSoC4/UART_1.c ****                                    UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 611:.\Generated_Source\PSoC4/UART_1.c ****                     {
 612:.\Generated_Source\PSoC4/UART_1.c ****                         rxData = 0u;
 613:.\Generated_Source\PSoC4/UART_1.c ****                     }
 614:.\Generated_Source\PSoC4/UART_1.c ****                 }
 615:.\Generated_Source\PSoC4/UART_1.c ****             }
 616:.\Generated_Source\PSoC4/UART_1.c **** 
 617:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 618:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 619:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 620:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 621:.\Generated_Source\PSoC4/UART_1.c **** 
 622:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 623:.\Generated_Source\PSoC4/UART_1.c **** 
 624:.\Generated_Source\PSoC4/UART_1.c ****             rxStatus =UART_1_RXSTATUS_REG;
 625:.\Generated_Source\PSoC4/UART_1.c ****             if((rxStatus & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u)
 626:.\Generated_Source\PSoC4/UART_1.c ****             {   /* Read received data from FIFO*/
 627:.\Generated_Source\PSoC4/UART_1.c ****                 rxData = UART_1_RXDATA_REG;
 628:.\Generated_Source\PSoC4/UART_1.c ****                 /*Check status on error*/
 629:.\Generated_Source\PSoC4/UART_1.c ****                 if((rxStatus & (UART_1_RX_STS_BREAK | UART_1_RX_STS_PAR_ERROR |
 630:.\Generated_Source\PSoC4/UART_1.c ****                                UART_1_RX_STS_STOP_ERROR | UART_1_RX_STS_OVERRUN)) != 0u)
 631:.\Generated_Source\PSoC4/UART_1.c ****                 {
 632:.\Generated_Source\PSoC4/UART_1.c ****                     rxData = 0u;
 633:.\Generated_Source\PSoC4/UART_1.c ****                 }
 634:.\Generated_Source\PSoC4/UART_1.c ****             }
 635:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 636:.\Generated_Source\PSoC4/UART_1.c **** 
 637:.\Generated_Source\PSoC4/UART_1.c ****         return(rxData);
 638:.\Generated_Source\PSoC4/UART_1.c ****     }
 639:.\Generated_Source\PSoC4/UART_1.c **** 
 640:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 17


 641:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 642:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetByte
 643:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 644:.\Generated_Source\PSoC4/UART_1.c ****     *
 645:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 646:.\Generated_Source\PSoC4/UART_1.c ****     *  Grab the next available byte of data from the recieve FIFO
 647:.\Generated_Source\PSoC4/UART_1.c ****     *
 648:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 649:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 650:.\Generated_Source\PSoC4/UART_1.c ****     *
 651:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 652:.\Generated_Source\PSoC4/UART_1.c ****     *  MSB contains Status Register and LSB contains UART RX data
 653:.\Generated_Source\PSoC4/UART_1.c ****     *
 654:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 655:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 656:.\Generated_Source\PSoC4/UART_1.c ****     *
 657:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 658:.\Generated_Source\PSoC4/UART_1.c ****     uint16 UART_1_GetByte(void) 
 659:.\Generated_Source\PSoC4/UART_1.c ****     {
 660:.\Generated_Source\PSoC4/UART_1.c ****         return ( ((uint16)UART_1_ReadRxStatus() << 8u) | UART_1_ReadRxData() );
 661:.\Generated_Source\PSoC4/UART_1.c ****     }
 662:.\Generated_Source\PSoC4/UART_1.c **** 
 663:.\Generated_Source\PSoC4/UART_1.c **** 
 664:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 665:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetRxBufferSize
 666:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 667:.\Generated_Source\PSoC4/UART_1.c ****     *
 668:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 669:.\Generated_Source\PSoC4/UART_1.c ****     *  Determine the amount of bytes left in the RX buffer and return the count in
 670:.\Generated_Source\PSoC4/UART_1.c ****     *  bytes
 671:.\Generated_Source\PSoC4/UART_1.c ****     *
 672:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 673:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 674:.\Generated_Source\PSoC4/UART_1.c ****     *
 675:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 676:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8: Integer count of the number of bytes left
 677:.\Generated_Source\PSoC4/UART_1.c ****     *  in the RX buffer
 678:.\Generated_Source\PSoC4/UART_1.c ****     *
 679:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 680:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - used to calculate left bytes.
 681:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - used to calculate left bytes.
 682:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - checked to decide left bytes amount.
 683:.\Generated_Source\PSoC4/UART_1.c ****     *
 684:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 685:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 686:.\Generated_Source\PSoC4/UART_1.c ****     *
 687:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 688:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the RX Buffer is.
 689:.\Generated_Source\PSoC4/UART_1.c ****     *
 690:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 691:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetRxBufferSize(void)
 692:.\Generated_Source\PSoC4/UART_1.c ****                                                             
 693:.\Generated_Source\PSoC4/UART_1.c ****     {
 694:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
 695:.\Generated_Source\PSoC4/UART_1.c **** 
 696:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 697:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 18


 698:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 699:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 700:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 701:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 702:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* UART_1_RX_INTERRUPT_ENABLED */
 703:.\Generated_Source\PSoC4/UART_1.c **** 
 704:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_rxBufferRead == UART_1_rxBufferWrite)
 705:.\Generated_Source\PSoC4/UART_1.c ****             {
 706:.\Generated_Source\PSoC4/UART_1.c ****                 if(UART_1_rxBufferLoopDetect > 0u)
 707:.\Generated_Source\PSoC4/UART_1.c ****                 {
 708:.\Generated_Source\PSoC4/UART_1.c ****                     size = UART_1_RXBUFFERSIZE;
 709:.\Generated_Source\PSoC4/UART_1.c ****                 }
 710:.\Generated_Source\PSoC4/UART_1.c ****                 else
 711:.\Generated_Source\PSoC4/UART_1.c ****                 {
 712:.\Generated_Source\PSoC4/UART_1.c ****                     size = 0u;
 713:.\Generated_Source\PSoC4/UART_1.c ****                 }
 714:.\Generated_Source\PSoC4/UART_1.c ****             }
 715:.\Generated_Source\PSoC4/UART_1.c ****             else if(UART_1_rxBufferRead < UART_1_rxBufferWrite)
 716:.\Generated_Source\PSoC4/UART_1.c ****             {
 717:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_rxBufferWrite - UART_1_rxBufferRead);
 718:.\Generated_Source\PSoC4/UART_1.c ****             }
 719:.\Generated_Source\PSoC4/UART_1.c ****             else
 720:.\Generated_Source\PSoC4/UART_1.c ****             {
 721:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_RXBUFFERSIZE - UART_1_rxBufferRead) + UART_1_rxBufferWrite;
 722:.\Generated_Source\PSoC4/UART_1.c ****             }
 723:.\Generated_Source\PSoC4/UART_1.c **** 
 724:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 725:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 726:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 727:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 728:.\Generated_Source\PSoC4/UART_1.c **** 
 729:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 730:.\Generated_Source\PSoC4/UART_1.c **** 
 731:.\Generated_Source\PSoC4/UART_1.c ****             /* We can only know if there is data in the fifo. */
 732:.\Generated_Source\PSoC4/UART_1.c ****             size = ((UART_1_RXSTATUS_REG & UART_1_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 733:.\Generated_Source\PSoC4/UART_1.c **** 
 734:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 735:.\Generated_Source\PSoC4/UART_1.c **** 
 736:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 737:.\Generated_Source\PSoC4/UART_1.c ****     }
 738:.\Generated_Source\PSoC4/UART_1.c **** 
 739:.\Generated_Source\PSoC4/UART_1.c **** 
 740:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 741:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearRxBuffer
 742:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 743:.\Generated_Source\PSoC4/UART_1.c ****     *
 744:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 745:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the RX RAM buffer by setting the read and write pointers both to zero.
 746:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears hardware RX FIFO.
 747:.\Generated_Source\PSoC4/UART_1.c ****     *
 748:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 749:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 750:.\Generated_Source\PSoC4/UART_1.c ****     *
 751:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 752:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 753:.\Generated_Source\PSoC4/UART_1.c ****     *
 754:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 19


 755:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferWrite - cleared to zero.
 756:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferRead - cleared to zero.
 757:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferLoopDetect - cleared to zero.
 758:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxBufferOverflow - cleared to zero.
 759:.\Generated_Source\PSoC4/UART_1.c ****     *
 760:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 761:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
 762:.\Generated_Source\PSoC4/UART_1.c ****     *
 763:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 764:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
 765:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may
 766:.\Generated_Source\PSoC4/UART_1.c ****     *  have remained in the RAM.
 767:.\Generated_Source\PSoC4/UART_1.c ****     *
 768:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
 769:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM or FIFO buffer will be lost.
 770:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 771:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearRxBuffer(void) 
 772:.\Generated_Source\PSoC4/UART_1.c ****     {
 773:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
 774:.\Generated_Source\PSoC4/UART_1.c **** 
 775:.\Generated_Source\PSoC4/UART_1.c ****         /* clear the HW FIFO */
 776:.\Generated_Source\PSoC4/UART_1.c ****         /* Enter critical section */
 777:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 778:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG |=  UART_1_RX_FIFO_CLR;
 779:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXDATA_AUX_CTL_REG &= (uint8)~UART_1_RX_FIFO_CLR;
 780:.\Generated_Source\PSoC4/UART_1.c ****         /* Exit critical section */
 781:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 782:.\Generated_Source\PSoC4/UART_1.c **** 
 783:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH)
 784:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Rx interrupt. */
 785:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
 786:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 787:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableRxInt();
 788:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 789:.\Generated_Source\PSoC4/UART_1.c **** 
 790:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferRead = 0u;
 791:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferWrite = 0u;
 792:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferLoopDetect = 0u;
 793:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_rxBufferOverflow = 0u;
 794:.\Generated_Source\PSoC4/UART_1.c **** 
 795:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Rx interrupt. */
 796:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_RX_INTERRUPT_ENABLED)
 797:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableRxInt();
 798:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_RX_INTERRUPT_ENABLED */
 799:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH */
 800:.\Generated_Source\PSoC4/UART_1.c **** 
 801:.\Generated_Source\PSoC4/UART_1.c ****     }
 802:.\Generated_Source\PSoC4/UART_1.c **** 
 803:.\Generated_Source\PSoC4/UART_1.c **** 
 804:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 805:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddressMode
 806:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 807:.\Generated_Source\PSoC4/UART_1.c ****     *
 808:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 809:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the receive addressing mode
 810:.\Generated_Source\PSoC4/UART_1.c ****     *
 811:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 20


 812:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: Enumerated value indicating the mode of RX addressing
 813:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 814:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 815:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 816:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 817:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 818:.\Generated_Source\PSoC4/UART_1.c ****     *                                               detection
 819:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 820:.\Generated_Source\PSoC4/UART_1.c ****     *                                               address detection
 821:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1__B_UART__AM_NONE - No address detection
 822:.\Generated_Source\PSoC4/UART_1.c ****     *
 823:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 824:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 825:.\Generated_Source\PSoC4/UART_1.c ****     *
 826:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 827:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressMode - the parameter stored in this variable for
 828:.\Generated_Source\PSoC4/UART_1.c ****     *   the farther usage in RX ISR.
 829:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_rxAddressDetected - set to initial state (0).
 830:.\Generated_Source\PSoC4/UART_1.c ****     *
 831:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 832:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddressMode(uint8 addressMode)
 833:.\Generated_Source\PSoC4/UART_1.c ****                                                         
 834:.\Generated_Source\PSoC4/UART_1.c ****     {
 835:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_RXHW_ADDRESS_ENABLED)
 836:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_CONTROL_REG_REMOVED)
 837:.\Generated_Source\PSoC4/UART_1.c ****                 if(addressMode != 0u) { }     /* release compiler warning */
 838:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_CONTROL_REG_REMOVED */
 839:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 tmpCtrl;
 840:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl = UART_1_CONTROL_REG & (uint8)~UART_1_CTRL_RXADDR_MODE_MASK;
 841:.\Generated_Source\PSoC4/UART_1.c ****                 tmpCtrl |= (uint8)(addressMode << UART_1_CTRL_RXADDR_MODE0_SHIFT);
 842:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_CONTROL_REG = tmpCtrl;
 843:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_RX_INTERRUPT_ENABLED && \
 844:.\Generated_Source\PSoC4/UART_1.c ****                    (UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH) )
 845:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressMode = addressMode;
 846:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_rxAddressDetected = 0u;
 847:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_RXBUFFERSIZE > UART_1_FIFO_LENGTH*/
 848:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED */
 849:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_RXHW_ADDRESS_ENABLED */
 850:.\Generated_Source\PSoC4/UART_1.c ****             if(addressMode != 0u) { }     /* release compiler warning */
 851:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_RXHW_ADDRESS_ENABLED */
 852:.\Generated_Source\PSoC4/UART_1.c ****     }
 853:.\Generated_Source\PSoC4/UART_1.c **** 
 854:.\Generated_Source\PSoC4/UART_1.c **** 
 855:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 856:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress1
 857:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 858:.\Generated_Source\PSoC4/UART_1.c ****     *
 859:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 860:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the first hardware address compare value
 861:.\Generated_Source\PSoC4/UART_1.c ****     *
 862:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 863:.\Generated_Source\PSoC4/UART_1.c ****     *  address
 864:.\Generated_Source\PSoC4/UART_1.c ****     *
 865:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 866:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 867:.\Generated_Source\PSoC4/UART_1.c ****     *
 868:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 21


 869:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress1(uint8 address) 
 870:.\Generated_Source\PSoC4/UART_1.c **** 
 871:.\Generated_Source\PSoC4/UART_1.c ****     {
 872:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS1_REG = address;
 873:.\Generated_Source\PSoC4/UART_1.c ****     }
 874:.\Generated_Source\PSoC4/UART_1.c **** 
 875:.\Generated_Source\PSoC4/UART_1.c **** 
 876:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 877:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetRxAddress2
 878:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 879:.\Generated_Source\PSoC4/UART_1.c ****     *
 880:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 881:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the second hardware address compare value
 882:.\Generated_Source\PSoC4/UART_1.c ****     *
 883:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 884:.\Generated_Source\PSoC4/UART_1.c ****     *  address
 885:.\Generated_Source\PSoC4/UART_1.c ****     *
 886:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 887:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 888:.\Generated_Source\PSoC4/UART_1.c ****     *
 889:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 890:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetRxAddress2(uint8 address) 
 891:.\Generated_Source\PSoC4/UART_1.c ****     {
 892:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_RXADDRESS2_REG = address;
 893:.\Generated_Source\PSoC4/UART_1.c ****     }
 894:.\Generated_Source\PSoC4/UART_1.c **** 
 895:.\Generated_Source\PSoC4/UART_1.c **** #endif  /* UART_1_RX_ENABLED || UART_1_HD_ENABLED*/
 896:.\Generated_Source\PSoC4/UART_1.c **** 
 897:.\Generated_Source\PSoC4/UART_1.c **** 
 898:.\Generated_Source\PSoC4/UART_1.c **** #if( (UART_1_TX_ENABLED) || (UART_1_HD_ENABLED) )
 899:.\Generated_Source\PSoC4/UART_1.c **** 
 900:.\Generated_Source\PSoC4/UART_1.c ****     #if(UART_1_TX_INTERRUPT_ENABLED)
 901:.\Generated_Source\PSoC4/UART_1.c **** 
 902:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
 903:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_EnableTxInt
 904:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 905:.\Generated_Source\PSoC4/UART_1.c ****         *
 906:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 907:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable TX interrupt generation
 908:.\Generated_Source\PSoC4/UART_1.c ****         *
 909:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 910:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 911:.\Generated_Source\PSoC4/UART_1.c ****         *
 912:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 913:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 914:.\Generated_Source\PSoC4/UART_1.c ****         *
 915:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 916:.\Generated_Source\PSoC4/UART_1.c ****         *  Enable the interrupt output -or- the interrupt component itself
 917:.\Generated_Source\PSoC4/UART_1.c ****         *
 918:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 919:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_EnableTxInt(void) 
 920:.\Generated_Source\PSoC4/UART_1.c ****         {
 921:.\Generated_Source\PSoC4/UART_1.c ****             CyIntEnable(UART_1_TX_VECT_NUM);
 922:.\Generated_Source\PSoC4/UART_1.c ****         }
 923:.\Generated_Source\PSoC4/UART_1.c **** 
 924:.\Generated_Source\PSoC4/UART_1.c **** 
 925:.\Generated_Source\PSoC4/UART_1.c ****         /*******************************************************************************
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 22


 926:.\Generated_Source\PSoC4/UART_1.c ****         * Function Name: UART_1_DisableTxInt
 927:.\Generated_Source\PSoC4/UART_1.c ****         ********************************************************************************
 928:.\Generated_Source\PSoC4/UART_1.c ****         *
 929:.\Generated_Source\PSoC4/UART_1.c ****         * Summary:
 930:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable TX interrupt generation
 931:.\Generated_Source\PSoC4/UART_1.c ****         *
 932:.\Generated_Source\PSoC4/UART_1.c ****         * Parameters:
 933:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 934:.\Generated_Source\PSoC4/UART_1.c ****         *
 935:.\Generated_Source\PSoC4/UART_1.c ****         * Return:
 936:.\Generated_Source\PSoC4/UART_1.c ****         *  None.
 937:.\Generated_Source\PSoC4/UART_1.c ****         *
 938:.\Generated_Source\PSoC4/UART_1.c ****         * Theory:
 939:.\Generated_Source\PSoC4/UART_1.c ****         *  Disable the interrupt output -or- the interrupt component itself
 940:.\Generated_Source\PSoC4/UART_1.c ****         *
 941:.\Generated_Source\PSoC4/UART_1.c ****         *******************************************************************************/
 942:.\Generated_Source\PSoC4/UART_1.c ****         void UART_1_DisableTxInt(void) 
 943:.\Generated_Source\PSoC4/UART_1.c ****         {
 944:.\Generated_Source\PSoC4/UART_1.c ****             CyIntDisable(UART_1_TX_VECT_NUM);
 945:.\Generated_Source\PSoC4/UART_1.c ****         }
 946:.\Generated_Source\PSoC4/UART_1.c **** 
 947:.\Generated_Source\PSoC4/UART_1.c ****     #endif /* UART_1_TX_INTERRUPT_ENABLED */
 948:.\Generated_Source\PSoC4/UART_1.c **** 
 949:.\Generated_Source\PSoC4/UART_1.c **** 
 950:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 951:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxInterruptMode
 952:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 953:.\Generated_Source\PSoC4/UART_1.c ****     *
 954:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 955:.\Generated_Source\PSoC4/UART_1.c ****     *  Configure which status bits trigger an interrupt event
 956:.\Generated_Source\PSoC4/UART_1.c ****     *
 957:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 958:.\Generated_Source\PSoC4/UART_1.c ****     *  intSrc: An or'd combination of the desired status bit masks (defined in
 959:.\Generated_Source\PSoC4/UART_1.c ****     *          the header file)
 960:.\Generated_Source\PSoC4/UART_1.c ****     *
 961:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 962:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
 963:.\Generated_Source\PSoC4/UART_1.c ****     *
 964:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
 965:.\Generated_Source\PSoC4/UART_1.c ****     *  Enables the output of specific status bits to the interrupt controller
 966:.\Generated_Source\PSoC4/UART_1.c ****     *
 967:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
 968:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxInterruptMode(uint8 intSrc) 
 969:.\Generated_Source\PSoC4/UART_1.c ****     {
 273              		.loc 1 969 0
 274              		.cfi_startproc
 275 0000 80B5     		push	{r7, lr}
 276              		.cfi_def_cfa_offset 8
 277              		.cfi_offset 7, -8
 278              		.cfi_offset 14, -4
 279 0002 82B0     		sub	sp, sp, #8
 280              		.cfi_def_cfa_offset 16
 281 0004 00AF     		add	r7, sp, #0
 282              		.cfi_def_cfa_register 7
 283 0006 021C     		mov	r2, r0
 284 0008 FB1D     		add	r3, r7, #7
 285 000a 1A70     		strb	r2, [r3]
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 23


 970:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXSTATUS_MASK_REG = intSrc;
 286              		.loc 1 970 0
 287 000c 034B     		ldr	r3, .L18
 288 000e FA1D     		add	r2, r7, #7
 289 0010 1278     		ldrb	r2, [r2]
 290 0012 1A70     		strb	r2, [r3]
 971:.\Generated_Source\PSoC4/UART_1.c ****     }
 291              		.loc 1 971 0
 292 0014 BD46     		mov	sp, r7
 293 0016 02B0     		add	sp, sp, #8
 294              		@ sp needed
 295 0018 80BD     		pop	{r7, pc}
 296              	.L19:
 297 001a C046     		.align	2
 298              	.L18:
 299 001c 80000F40 		.word	1074724992
 300              		.cfi_endproc
 301              	.LFE6:
 302              		.size	UART_1_SetTxInterruptMode, .-UART_1_SetTxInterruptMode
 303              		.section	.text.UART_1_WriteTxData,"ax",%progbits
 304              		.align	2
 305              		.global	UART_1_WriteTxData
 306              		.code	16
 307              		.thumb_func
 308              		.type	UART_1_WriteTxData, %function
 309              	UART_1_WriteTxData:
 310              	.LFB7:
 972:.\Generated_Source\PSoC4/UART_1.c **** 
 973:.\Generated_Source\PSoC4/UART_1.c **** 
 974:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
 975:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_WriteTxData
 976:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
 977:.\Generated_Source\PSoC4/UART_1.c ****     *
 978:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
 979:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a byte of data to the Transmit FIFO or TX buffer to be sent when the
 980:.\Generated_Source\PSoC4/UART_1.c ****     *  bus is available. WriteTxData sends a byte without checking for buffer room
 981:.\Generated_Source\PSoC4/UART_1.c ****     *  or status. It is up to the user to separately check status.
 982:.\Generated_Source\PSoC4/UART_1.c ****     *
 983:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
 984:.\Generated_Source\PSoC4/UART_1.c ****     *  TXDataByte: byte of data to place in the transmit FIFO
 985:.\Generated_Source\PSoC4/UART_1.c ****     *
 986:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
 987:.\Generated_Source\PSoC4/UART_1.c ****     * void
 988:.\Generated_Source\PSoC4/UART_1.c ****     *
 989:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
 990:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
 991:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
 992:.\Generated_Source\PSoC4/UART_1.c ****     *    incremented after each byte saved to buffer.
 993:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
 994:.\Generated_Source\PSoC4/UART_1.c ****     *    checked to identify the condition to write to FIFO directly or to TX buffer
 995:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
 996:.\Generated_Source\PSoC4/UART_1.c ****     *    initialized.
 997:.\Generated_Source\PSoC4/UART_1.c ****     *
 998:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
 999:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1000:.\Generated_Source\PSoC4/UART_1.c ****     *
1001:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 24


1002:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_WriteTxData(uint8 txDataByte) 
1003:.\Generated_Source\PSoC4/UART_1.c ****     {
 311              		.loc 1 1003 0
 312              		.cfi_startproc
 313 0000 80B5     		push	{r7, lr}
 314              		.cfi_def_cfa_offset 8
 315              		.cfi_offset 7, -8
 316              		.cfi_offset 14, -4
 317 0002 82B0     		sub	sp, sp, #8
 318              		.cfi_def_cfa_offset 16
 319 0004 00AF     		add	r7, sp, #0
 320              		.cfi_def_cfa_register 7
 321 0006 021C     		mov	r2, r0
 322 0008 FB1D     		add	r3, r7, #7
 323 000a 1A70     		strb	r2, [r3]
1004:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1005:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 324              		.loc 1 1005 0
 325 000c 054B     		ldr	r3, .L22
 326 000e 1B78     		ldrb	r3, [r3]
 327 0010 002B     		cmp	r3, #0
 328 0012 03D0     		beq	.L20
1006:.\Generated_Source\PSoC4/UART_1.c ****         {
1007:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1008:.\Generated_Source\PSoC4/UART_1.c **** 
1009:.\Generated_Source\PSoC4/UART_1.c ****                 /* Disable Tx interrupt. */
1010:.\Generated_Source\PSoC4/UART_1.c ****                 /* Protect variables that could change on interrupt. */
1011:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1012:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_DisableTxInt();
1013:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1014:.\Generated_Source\PSoC4/UART_1.c **** 
1015:.\Generated_Source\PSoC4/UART_1.c ****                 if( (UART_1_txBufferRead == UART_1_txBufferWrite) &&
1016:.\Generated_Source\PSoC4/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1017:.\Generated_Source\PSoC4/UART_1.c ****                 {
1018:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add directly to the FIFO. */
1019:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1020:.\Generated_Source\PSoC4/UART_1.c ****                 }
1021:.\Generated_Source\PSoC4/UART_1.c ****                 else
1022:.\Generated_Source\PSoC4/UART_1.c ****                 {
1023:.\Generated_Source\PSoC4/UART_1.c ****                     if(UART_1_txBufferWrite >= UART_1_TXBUFFERSIZE)
1024:.\Generated_Source\PSoC4/UART_1.c ****                     {
1025:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_txBufferWrite = 0u;
1026:.\Generated_Source\PSoC4/UART_1.c ****                     }
1027:.\Generated_Source\PSoC4/UART_1.c **** 
1028:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBuffer[UART_1_txBufferWrite] = txDataByte;
1029:.\Generated_Source\PSoC4/UART_1.c **** 
1030:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add to the software buffer. */
1031:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite++;
1032:.\Generated_Source\PSoC4/UART_1.c **** 
1033:.\Generated_Source\PSoC4/UART_1.c ****                 }
1034:.\Generated_Source\PSoC4/UART_1.c **** 
1035:.\Generated_Source\PSoC4/UART_1.c ****                 /* Enable Tx interrupt. */
1036:.\Generated_Source\PSoC4/UART_1.c ****                 #if(UART_1_TX_INTERRUPT_ENABLED)
1037:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_EnableTxInt();
1038:.\Generated_Source\PSoC4/UART_1.c ****                 #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1039:.\Generated_Source\PSoC4/UART_1.c **** 
1040:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 25


1041:.\Generated_Source\PSoC4/UART_1.c **** 
1042:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
1043:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 329              		.loc 1 1043 0
 330 0014 044B     		ldr	r3, .L22+4
 331 0016 FA1D     		add	r2, r7, #7
 332 0018 1278     		ldrb	r2, [r2]
 333 001a 1A70     		strb	r2, [r3]
 334              	.L20:
1044:.\Generated_Source\PSoC4/UART_1.c **** 
1045:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1046:.\Generated_Source\PSoC4/UART_1.c ****         }
1047:.\Generated_Source\PSoC4/UART_1.c ****     }
 335              		.loc 1 1047 0
 336 001c BD46     		mov	sp, r7
 337 001e 02B0     		add	sp, sp, #8
 338              		@ sp needed
 339 0020 80BD     		pop	{r7, pc}
 340              	.L23:
 341 0022 C046     		.align	2
 342              	.L22:
 343 0024 00000000 		.word	UART_1_initVar
 344 0028 40000F40 		.word	1074724928
 345              		.cfi_endproc
 346              	.LFE7:
 347              		.size	UART_1_WriteTxData, .-UART_1_WriteTxData
 348              		.section	.text.UART_1_ReadTxStatus,"ax",%progbits
 349              		.align	2
 350              		.global	UART_1_ReadTxStatus
 351              		.code	16
 352              		.thumb_func
 353              		.type	UART_1_ReadTxStatus, %function
 354              	UART_1_ReadTxStatus:
 355              	.LFB8:
1048:.\Generated_Source\PSoC4/UART_1.c **** 
1049:.\Generated_Source\PSoC4/UART_1.c **** 
1050:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1051:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ReadTxStatus
1052:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1053:.\Generated_Source\PSoC4/UART_1.c ****     *
1054:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1055:.\Generated_Source\PSoC4/UART_1.c ****     *  Read the status register for the component
1056:.\Generated_Source\PSoC4/UART_1.c ****     *
1057:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1058:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1059:.\Generated_Source\PSoC4/UART_1.c ****     *
1060:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1061:.\Generated_Source\PSoC4/UART_1.c ****     *  Contents of the status register
1062:.\Generated_Source\PSoC4/UART_1.c ****     *
1063:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1064:.\Generated_Source\PSoC4/UART_1.c ****     *  This function reads the status register which is clear on read. It is up to
1065:.\Generated_Source\PSoC4/UART_1.c ****     *  the user to handle all bits in this return value accordingly, even if the bit
1066:.\Generated_Source\PSoC4/UART_1.c ****     *  was not enabled as an interrupt source the event happened and must be handled
1067:.\Generated_Source\PSoC4/UART_1.c ****     *  accordingly.
1068:.\Generated_Source\PSoC4/UART_1.c ****     *
1069:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1070:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_ReadTxStatus(void) 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 26


1071:.\Generated_Source\PSoC4/UART_1.c ****     {
 356              		.loc 1 1071 0
 357              		.cfi_startproc
 358 0000 80B5     		push	{r7, lr}
 359              		.cfi_def_cfa_offset 8
 360              		.cfi_offset 7, -8
 361              		.cfi_offset 14, -4
 362 0002 00AF     		add	r7, sp, #0
 363              		.cfi_def_cfa_register 7
1072:.\Generated_Source\PSoC4/UART_1.c ****         return(UART_1_TXSTATUS_REG);
 364              		.loc 1 1072 0
 365 0004 024B     		ldr	r3, .L26
 366 0006 1B78     		ldrb	r3, [r3]
 367 0008 DBB2     		uxtb	r3, r3
1073:.\Generated_Source\PSoC4/UART_1.c ****     }
 368              		.loc 1 1073 0
 369 000a 181C     		mov	r0, r3
 370 000c BD46     		mov	sp, r7
 371              		@ sp needed
 372 000e 80BD     		pop	{r7, pc}
 373              	.L27:
 374              		.align	2
 375              	.L26:
 376 0010 60000F40 		.word	1074724960
 377              		.cfi_endproc
 378              	.LFE8:
 379              		.size	UART_1_ReadTxStatus, .-UART_1_ReadTxStatus
 380              		.section	.text.UART_1_PutChar,"ax",%progbits
 381              		.align	2
 382              		.global	UART_1_PutChar
 383              		.code	16
 384              		.thumb_func
 385              		.type	UART_1_PutChar, %function
 386              	UART_1_PutChar:
 387              	.LFB9:
1074:.\Generated_Source\PSoC4/UART_1.c **** 
1075:.\Generated_Source\PSoC4/UART_1.c **** 
1076:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1077:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutChar
1078:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1079:.\Generated_Source\PSoC4/UART_1.c ****     *
1080:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1081:.\Generated_Source\PSoC4/UART_1.c ****     *  Wait to send byte until TX register or buffer has room.
1082:.\Generated_Source\PSoC4/UART_1.c ****     *
1083:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1084:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: The 8-bit data value to send across the UART.
1085:.\Generated_Source\PSoC4/UART_1.c ****     *
1086:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1087:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1088:.\Generated_Source\PSoC4/UART_1.c ****     *
1089:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1090:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBuffer - RAM buffer pointer for save data for transmission
1091:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cyclic index for write to txBuffer,
1092:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer and incremented after each byte
1093:.\Generated_Source\PSoC4/UART_1.c ****     *     saved to buffer.
1094:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cyclic index for read from txBuffer,
1095:.\Generated_Source\PSoC4/UART_1.c ****     *     checked to identify free space in txBuffer.
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 27


1096:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1097:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1098:.\Generated_Source\PSoC4/UART_1.c ****     *
1099:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1100:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1101:.\Generated_Source\PSoC4/UART_1.c ****     *
1102:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1103:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to transmit any byte of data in a single transfer
1104:.\Generated_Source\PSoC4/UART_1.c ****     *
1105:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1106:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutChar(uint8 txDataByte) 
1107:.\Generated_Source\PSoC4/UART_1.c ****     {
 388              		.loc 1 1107 0
 389              		.cfi_startproc
 390 0000 80B5     		push	{r7, lr}
 391              		.cfi_def_cfa_offset 8
 392              		.cfi_offset 7, -8
 393              		.cfi_offset 14, -4
 394 0002 82B0     		sub	sp, sp, #8
 395              		.cfi_def_cfa_offset 16
 396 0004 00AF     		add	r7, sp, #0
 397              		.cfi_def_cfa_register 7
 398 0006 021C     		mov	r2, r0
 399 0008 FB1D     		add	r3, r7, #7
 400 000a 1A70     		strb	r2, [r3]
1108:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1109:.\Generated_Source\PSoC4/UART_1.c ****                 /* The temporary output pointer is used since it takes two instructions
1110:.\Generated_Source\PSoC4/UART_1.c ****                 *  to increment with a wrap, and we can't risk doing that with the real
1111:.\Generated_Source\PSoC4/UART_1.c ****                 *  pointer and getting an interrupt in between instructions.
1112:.\Generated_Source\PSoC4/UART_1.c ****                 */
1113:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 loc_txBufferWrite;
1114:.\Generated_Source\PSoC4/UART_1.c ****                 uint8 loc_txBufferRead;
1115:.\Generated_Source\PSoC4/UART_1.c **** 
1116:.\Generated_Source\PSoC4/UART_1.c ****                 do{
1117:.\Generated_Source\PSoC4/UART_1.c ****                     /* Block if software buffer is full, so we don't overwrite. */
1118:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1119:.\Generated_Source\PSoC4/UART_1.c ****                         /* Disable TX interrupt to protect variables that could change on interrupt
1120:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1121:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1122:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferWrite = UART_1_txBufferWrite;
1123:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferRead = UART_1_txBufferRead;
1124:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1125:.\Generated_Source\PSoC4/UART_1.c ****                         /* Enable interrupt to continue transmission */
1126:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1127:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1128:.\Generated_Source\PSoC4/UART_1.c ****                 }while( (loc_txBufferWrite < loc_txBufferRead) ? (loc_txBufferWrite == (loc_txBuffe
1129:.\Generated_Source\PSoC4/UART_1.c ****                                         ((loc_txBufferWrite - loc_txBufferRead) ==
1130:.\Generated_Source\PSoC4/UART_1.c ****                                         (uint8)(UART_1_TXBUFFERSIZE - 1u)) );
1131:.\Generated_Source\PSoC4/UART_1.c **** 
1132:.\Generated_Source\PSoC4/UART_1.c ****                 if( (loc_txBufferRead == loc_txBufferWrite) &&
1133:.\Generated_Source\PSoC4/UART_1.c ****                     ((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) == 0u) )
1134:.\Generated_Source\PSoC4/UART_1.c ****                 {
1135:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add directly to the FIFO. */
1136:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = txDataByte;
1137:.\Generated_Source\PSoC4/UART_1.c ****                 }
1138:.\Generated_Source\PSoC4/UART_1.c ****                 else
1139:.\Generated_Source\PSoC4/UART_1.c ****                 {
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 28


1140:.\Generated_Source\PSoC4/UART_1.c ****                     if(loc_txBufferWrite >= UART_1_TXBUFFERSIZE)
1141:.\Generated_Source\PSoC4/UART_1.c ****                     {
1142:.\Generated_Source\PSoC4/UART_1.c ****                         loc_txBufferWrite = 0u;
1143:.\Generated_Source\PSoC4/UART_1.c ****                     }
1144:.\Generated_Source\PSoC4/UART_1.c ****                     /* Add to the software buffer. */
1145:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBuffer[loc_txBufferWrite] = txDataByte;
1146:.\Generated_Source\PSoC4/UART_1.c ****                     loc_txBufferWrite++;
1147:.\Generated_Source\PSoC4/UART_1.c **** 
1148:.\Generated_Source\PSoC4/UART_1.c ****                     /* Finally, update the real output pointer */
1149:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1150:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntDisable(UART_1_TX_VECT_NUM);
1151:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1152:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_txBufferWrite = loc_txBufferWrite;
1153:.\Generated_Source\PSoC4/UART_1.c ****                     #if ((UART_1_TXBUFFERSIZE > UART_1_MAX_BYTE_VALUE) && (CY_PSOC3))
1154:.\Generated_Source\PSoC4/UART_1.c ****                         CyIntEnable(UART_1_TX_VECT_NUM);
1155:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End TXBUFFERSIZE > 255 */
1156:.\Generated_Source\PSoC4/UART_1.c ****                 }
1157:.\Generated_Source\PSoC4/UART_1.c **** 
1158:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1159:.\Generated_Source\PSoC4/UART_1.c **** 
1160:.\Generated_Source\PSoC4/UART_1.c ****                 while((UART_1_TXSTATUS_REG & UART_1_TX_STS_FIFO_FULL) != 0u)
 401              		.loc 1 1160 0
 402 000c C046     		mov	r8, r8
 403              	.L29:
 404              		.loc 1 1160 0 is_stmt 0 discriminator 1
 405 000e 074B     		ldr	r3, .L30
 406 0010 1B78     		ldrb	r3, [r3]
 407 0012 DBB2     		uxtb	r3, r3
 408 0014 1A1C     		mov	r2, r3
 409 0016 0423     		mov	r3, #4
 410 0018 1340     		and	r3, r2
 411 001a F8D1     		bne	.L29
1161:.\Generated_Source\PSoC4/UART_1.c ****                 {
1162:.\Generated_Source\PSoC4/UART_1.c ****                     ; /* Wait for room in the FIFO. */
1163:.\Generated_Source\PSoC4/UART_1.c ****                 }
1164:.\Generated_Source\PSoC4/UART_1.c **** 
1165:.\Generated_Source\PSoC4/UART_1.c ****                 /* Add directly to the FIFO. */
1166:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_TXDATA_REG = txDataByte;
 412              		.loc 1 1166 0 is_stmt 1
 413 001c 044B     		ldr	r3, .L30+4
 414 001e FA1D     		add	r2, r7, #7
 415 0020 1278     		ldrb	r2, [r2]
 416 0022 1A70     		strb	r2, [r3]
1167:.\Generated_Source\PSoC4/UART_1.c **** 
1168:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1169:.\Generated_Source\PSoC4/UART_1.c ****     }
 417              		.loc 1 1169 0
 418 0024 BD46     		mov	sp, r7
 419 0026 02B0     		add	sp, sp, #8
 420              		@ sp needed
 421 0028 80BD     		pop	{r7, pc}
 422              	.L31:
 423 002a C046     		.align	2
 424              	.L30:
 425 002c 60000F40 		.word	1074724960
 426 0030 40000F40 		.word	1074724928
 427              		.cfi_endproc
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 29


 428              	.LFE9:
 429              		.size	UART_1_PutChar, .-UART_1_PutChar
 430              		.section	.text.UART_1_PutString,"ax",%progbits
 431              		.align	2
 432              		.global	UART_1_PutString
 433              		.code	16
 434              		.thumb_func
 435              		.type	UART_1_PutString, %function
 436              	UART_1_PutString:
 437              	.LFB10:
1170:.\Generated_Source\PSoC4/UART_1.c **** 
1171:.\Generated_Source\PSoC4/UART_1.c **** 
1172:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1173:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutString
1174:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1175:.\Generated_Source\PSoC4/UART_1.c ****     *
1176:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1177:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1178:.\Generated_Source\PSoC4/UART_1.c ****     *
1179:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1180:.\Generated_Source\PSoC4/UART_1.c ****     *  string: char pointer to character string of Data to Send.
1181:.\Generated_Source\PSoC4/UART_1.c ****     *
1182:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1183:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1184:.\Generated_Source\PSoC4/UART_1.c ****     *
1185:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1186:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1187:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1188:.\Generated_Source\PSoC4/UART_1.c ****     *
1189:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1190:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1191:.\Generated_Source\PSoC4/UART_1.c ****     *
1192:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1193:.\Generated_Source\PSoC4/UART_1.c ****     *  This function will block if there is not enough memory to place the whole
1194:.\Generated_Source\PSoC4/UART_1.c ****     *  string, it will block until the entire string has been written to the
1195:.\Generated_Source\PSoC4/UART_1.c ****     *  transmit buffer.
1196:.\Generated_Source\PSoC4/UART_1.c ****     *
1197:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1198:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutString(const char8 string[]) 
1199:.\Generated_Source\PSoC4/UART_1.c ****     {
 438              		.loc 1 1199 0
 439              		.cfi_startproc
 440 0000 80B5     		push	{r7, lr}
 441              		.cfi_def_cfa_offset 8
 442              		.cfi_offset 7, -8
 443              		.cfi_offset 14, -4
 444 0002 84B0     		sub	sp, sp, #16
 445              		.cfi_def_cfa_offset 24
 446 0004 00AF     		add	r7, sp, #0
 447              		.cfi_def_cfa_register 7
 448 0006 7860     		str	r0, [r7, #4]
1200:.\Generated_Source\PSoC4/UART_1.c ****         uint16 buf_index = 0u;
 449              		.loc 1 1200 0
 450 0008 3B1C     		mov	r3, r7
 451 000a 0E33     		add	r3, r3, #14
 452 000c 0022     		mov	r2, #0
 453 000e 1A80     		strh	r2, [r3]
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 30


1201:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1202:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 454              		.loc 1 1202 0
 455 0010 0F4B     		ldr	r3, .L36
 456 0012 1B78     		ldrb	r3, [r3]
 457 0014 002B     		cmp	r3, #0
 458 0016 18D0     		beq	.L32
1203:.\Generated_Source\PSoC4/UART_1.c ****         {
1204:.\Generated_Source\PSoC4/UART_1.c ****             /* This is a blocking function, it will not exit until all data is sent*/
1205:.\Generated_Source\PSoC4/UART_1.c ****             while(string[buf_index] != (char8)0)
 459              		.loc 1 1205 0
 460 0018 0FE0     		b	.L34
 461              	.L35:
1206:.\Generated_Source\PSoC4/UART_1.c ****             {
1207:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar((uint8)string[buf_index]);
 462              		.loc 1 1207 0
 463 001a 3B1C     		mov	r3, r7
 464 001c 0E33     		add	r3, r3, #14
 465 001e 1B88     		ldrh	r3, [r3]
 466 0020 7A68     		ldr	r2, [r7, #4]
 467 0022 D318     		add	r3, r2, r3
 468 0024 1B78     		ldrb	r3, [r3]
 469 0026 181C     		mov	r0, r3
 470 0028 FFF7FEFF 		bl	UART_1_PutChar
1208:.\Generated_Source\PSoC4/UART_1.c ****                 buf_index++;
 471              		.loc 1 1208 0
 472 002c 3B1C     		mov	r3, r7
 473 002e 0E33     		add	r3, r3, #14
 474 0030 1A88     		ldrh	r2, [r3]
 475 0032 3B1C     		mov	r3, r7
 476 0034 0E33     		add	r3, r3, #14
 477 0036 0132     		add	r2, r2, #1
 478 0038 1A80     		strh	r2, [r3]
 479              	.L34:
1205:.\Generated_Source\PSoC4/UART_1.c ****             while(string[buf_index] != (char8)0)
 480              		.loc 1 1205 0 discriminator 1
 481 003a 3B1C     		mov	r3, r7
 482 003c 0E33     		add	r3, r3, #14
 483 003e 1B88     		ldrh	r3, [r3]
 484 0040 7A68     		ldr	r2, [r7, #4]
 485 0042 D318     		add	r3, r2, r3
 486 0044 1B78     		ldrb	r3, [r3]
 487 0046 002B     		cmp	r3, #0
 488 0048 E7D1     		bne	.L35
 489              	.L32:
1209:.\Generated_Source\PSoC4/UART_1.c ****             }
1210:.\Generated_Source\PSoC4/UART_1.c ****         }
1211:.\Generated_Source\PSoC4/UART_1.c ****     }
 490              		.loc 1 1211 0
 491 004a BD46     		mov	sp, r7
 492 004c 04B0     		add	sp, sp, #16
 493              		@ sp needed
 494 004e 80BD     		pop	{r7, pc}
 495              	.L37:
 496              		.align	2
 497              	.L36:
 498 0050 00000000 		.word	UART_1_initVar
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 31


 499              		.cfi_endproc
 500              	.LFE10:
 501              		.size	UART_1_PutString, .-UART_1_PutString
 502              		.section	.text.UART_1_PutArray,"ax",%progbits
 503              		.align	2
 504              		.global	UART_1_PutArray
 505              		.code	16
 506              		.thumb_func
 507              		.type	UART_1_PutArray, %function
 508              	UART_1_PutArray:
 509              	.LFB11:
1212:.\Generated_Source\PSoC4/UART_1.c **** 
1213:.\Generated_Source\PSoC4/UART_1.c **** 
1214:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1215:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutArray
1216:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1217:.\Generated_Source\PSoC4/UART_1.c ****     *
1218:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1219:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Sequence of bytes on the Transmit line. Data comes from RAM or ROM.
1220:.\Generated_Source\PSoC4/UART_1.c ****     *
1221:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1222:.\Generated_Source\PSoC4/UART_1.c ****     *  string: Address of the memory array residing in RAM or ROM.
1223:.\Generated_Source\PSoC4/UART_1.c ****     *  byteCount: Number of Bytes to be transmitted.
1224:.\Generated_Source\PSoC4/UART_1.c ****     *
1225:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1226:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1227:.\Generated_Source\PSoC4/UART_1.c ****     *
1228:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1229:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1230:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1231:.\Generated_Source\PSoC4/UART_1.c ****     *
1232:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1233:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1234:.\Generated_Source\PSoC4/UART_1.c ****     *
1235:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1236:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutArray(const uint8 string[], uint8 byteCount)
1237:.\Generated_Source\PSoC4/UART_1.c ****                                                                     
1238:.\Generated_Source\PSoC4/UART_1.c ****     {
 510              		.loc 1 1238 0
 511              		.cfi_startproc
 512 0000 80B5     		push	{r7, lr}
 513              		.cfi_def_cfa_offset 8
 514              		.cfi_offset 7, -8
 515              		.cfi_offset 14, -4
 516 0002 84B0     		sub	sp, sp, #16
 517              		.cfi_def_cfa_offset 24
 518 0004 00AF     		add	r7, sp, #0
 519              		.cfi_def_cfa_register 7
 520 0006 7860     		str	r0, [r7, #4]
 521 0008 0A1C     		mov	r2, r1
 522 000a FB1C     		add	r3, r7, #3
 523 000c 1A70     		strb	r2, [r3]
1239:.\Generated_Source\PSoC4/UART_1.c ****         uint8 buf_index = 0u;
 524              		.loc 1 1239 0
 525 000e 3B1C     		mov	r3, r7
 526 0010 0F33     		add	r3, r3, #15
 527 0012 0022     		mov	r2, #0
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 32


 528 0014 1A70     		strb	r2, [r3]
1240:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1241:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 529              		.loc 1 1241 0
 530 0016 0F4B     		ldr	r3, .L41
 531 0018 1B78     		ldrb	r3, [r3]
 532 001a 002B     		cmp	r3, #0
 533 001c 16D0     		beq	.L38
 534              	.L40:
1242:.\Generated_Source\PSoC4/UART_1.c ****         {
1243:.\Generated_Source\PSoC4/UART_1.c ****             do
1244:.\Generated_Source\PSoC4/UART_1.c ****             {
1245:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_PutChar(string[buf_index]);
 535              		.loc 1 1245 0 discriminator 1
 536 001e 3B1C     		mov	r3, r7
 537 0020 0F33     		add	r3, r3, #15
 538 0022 1B78     		ldrb	r3, [r3]
 539 0024 7A68     		ldr	r2, [r7, #4]
 540 0026 D318     		add	r3, r2, r3
 541 0028 1B78     		ldrb	r3, [r3]
 542 002a 181C     		mov	r0, r3
 543 002c FFF7FEFF 		bl	UART_1_PutChar
1246:.\Generated_Source\PSoC4/UART_1.c ****                 buf_index++;
 544              		.loc 1 1246 0 discriminator 1
 545 0030 3B1C     		mov	r3, r7
 546 0032 0F33     		add	r3, r3, #15
 547 0034 1A78     		ldrb	r2, [r3]
 548 0036 3B1C     		mov	r3, r7
 549 0038 0F33     		add	r3, r3, #15
 550 003a 0132     		add	r2, r2, #1
 551 003c 1A70     		strb	r2, [r3]
1247:.\Generated_Source\PSoC4/UART_1.c ****             }while(buf_index < byteCount);
 552              		.loc 1 1247 0 discriminator 1
 553 003e 3A1C     		mov	r2, r7
 554 0040 0F32     		add	r2, r2, #15
 555 0042 FB1C     		add	r3, r7, #3
 556 0044 1278     		ldrb	r2, [r2]
 557 0046 1B78     		ldrb	r3, [r3]
 558 0048 9A42     		cmp	r2, r3
 559 004a E8D3     		bcc	.L40
 560              	.L38:
1248:.\Generated_Source\PSoC4/UART_1.c ****         }
1249:.\Generated_Source\PSoC4/UART_1.c ****     }
 561              		.loc 1 1249 0
 562 004c BD46     		mov	sp, r7
 563 004e 04B0     		add	sp, sp, #16
 564              		@ sp needed
 565 0050 80BD     		pop	{r7, pc}
 566              	.L42:
 567 0052 C046     		.align	2
 568              	.L41:
 569 0054 00000000 		.word	UART_1_initVar
 570              		.cfi_endproc
 571              	.LFE11:
 572              		.size	UART_1_PutArray, .-UART_1_PutArray
 573              		.section	.text.UART_1_PutCRLF,"ax",%progbits
 574              		.align	2
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 33


 575              		.global	UART_1_PutCRLF
 576              		.code	16
 577              		.thumb_func
 578              		.type	UART_1_PutCRLF, %function
 579              	UART_1_PutCRLF:
 580              	.LFB12:
1250:.\Generated_Source\PSoC4/UART_1.c **** 
1251:.\Generated_Source\PSoC4/UART_1.c **** 
1252:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1253:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_PutCRLF
1254:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1255:.\Generated_Source\PSoC4/UART_1.c ****     *
1256:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1257:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a character and then carriage return and line feed.
1258:.\Generated_Source\PSoC4/UART_1.c ****     *
1259:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1260:.\Generated_Source\PSoC4/UART_1.c ****     *  txDataByte: uint8 Character to send.
1261:.\Generated_Source\PSoC4/UART_1.c ****     *
1262:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1263:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1264:.\Generated_Source\PSoC4/UART_1.c ****     *
1265:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1266:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1267:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1268:.\Generated_Source\PSoC4/UART_1.c ****     *
1269:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1270:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1271:.\Generated_Source\PSoC4/UART_1.c ****     *
1272:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1273:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_PutCRLF(uint8 txDataByte) 
1274:.\Generated_Source\PSoC4/UART_1.c ****     {
 581              		.loc 1 1274 0
 582              		.cfi_startproc
 583 0000 80B5     		push	{r7, lr}
 584              		.cfi_def_cfa_offset 8
 585              		.cfi_offset 7, -8
 586              		.cfi_offset 14, -4
 587 0002 82B0     		sub	sp, sp, #8
 588              		.cfi_def_cfa_offset 16
 589 0004 00AF     		add	r7, sp, #0
 590              		.cfi_def_cfa_register 7
 591 0006 021C     		mov	r2, r0
 592 0008 FB1D     		add	r3, r7, #7
 593 000a 1A70     		strb	r2, [r3]
1275:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1276:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 594              		.loc 1 1276 0
 595 000c 084B     		ldr	r3, .L45
 596 000e 1B78     		ldrb	r3, [r3]
 597 0010 002B     		cmp	r3, #0
 598 0012 0AD0     		beq	.L43
1277:.\Generated_Source\PSoC4/UART_1.c ****         {
1278:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(txDataByte);
 599              		.loc 1 1278 0
 600 0014 FB1D     		add	r3, r7, #7
 601 0016 1B78     		ldrb	r3, [r3]
 602 0018 181C     		mov	r0, r3
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 34


 603 001a FFF7FEFF 		bl	UART_1_PutChar
1279:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Du);
 604              		.loc 1 1279 0
 605 001e 0D20     		mov	r0, #13
 606 0020 FFF7FEFF 		bl	UART_1_PutChar
1280:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_PutChar(0x0Au);
 607              		.loc 1 1280 0
 608 0024 0A20     		mov	r0, #10
 609 0026 FFF7FEFF 		bl	UART_1_PutChar
 610              	.L43:
1281:.\Generated_Source\PSoC4/UART_1.c ****         }
1282:.\Generated_Source\PSoC4/UART_1.c ****     }
 611              		.loc 1 1282 0
 612 002a BD46     		mov	sp, r7
 613 002c 02B0     		add	sp, sp, #8
 614              		@ sp needed
 615 002e 80BD     		pop	{r7, pc}
 616              	.L46:
 617              		.align	2
 618              	.L45:
 619 0030 00000000 		.word	UART_1_initVar
 620              		.cfi_endproc
 621              	.LFE12:
 622              		.size	UART_1_PutCRLF, .-UART_1_PutCRLF
 623              		.section	.text.UART_1_GetTxBufferSize,"ax",%progbits
 624              		.align	2
 625              		.global	UART_1_GetTxBufferSize
 626              		.code	16
 627              		.thumb_func
 628              		.type	UART_1_GetTxBufferSize, %function
 629              	UART_1_GetTxBufferSize:
 630              	.LFB13:
1283:.\Generated_Source\PSoC4/UART_1.c **** 
1284:.\Generated_Source\PSoC4/UART_1.c **** 
1285:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1286:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_GetTxBufferSize
1287:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1288:.\Generated_Source\PSoC4/UART_1.c ****     *
1289:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1290:.\Generated_Source\PSoC4/UART_1.c ****     *  Determine the amount of space left in the TX buffer and return the count in
1291:.\Generated_Source\PSoC4/UART_1.c ****     *  bytes
1292:.\Generated_Source\PSoC4/UART_1.c ****     *
1293:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1294:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1295:.\Generated_Source\PSoC4/UART_1.c ****     *
1296:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1297:.\Generated_Source\PSoC4/UART_1.c ****     *  Integer count of the number of bytes left in the TX buffer
1298:.\Generated_Source\PSoC4/UART_1.c ****     *
1299:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1300:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - used to calculate left space.
1301:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - used to calculate left space.
1302:.\Generated_Source\PSoC4/UART_1.c ****     *
1303:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1304:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1305:.\Generated_Source\PSoC4/UART_1.c ****     *
1306:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1307:.\Generated_Source\PSoC4/UART_1.c ****     *  Allows the user to find out how full the TX Buffer is.
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 35


1308:.\Generated_Source\PSoC4/UART_1.c ****     *
1309:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1310:.\Generated_Source\PSoC4/UART_1.c ****     uint8 UART_1_GetTxBufferSize(void)
1311:.\Generated_Source\PSoC4/UART_1.c ****                                                             
1312:.\Generated_Source\PSoC4/UART_1.c ****     {
 631              		.loc 1 1312 0
 632              		.cfi_startproc
 633 0000 80B5     		push	{r7, lr}
 634              		.cfi_def_cfa_offset 8
 635              		.cfi_offset 7, -8
 636              		.cfi_offset 14, -4
 637 0002 82B0     		sub	sp, sp, #8
 638              		.cfi_def_cfa_offset 16
 639 0004 00AF     		add	r7, sp, #0
 640              		.cfi_def_cfa_register 7
1313:.\Generated_Source\PSoC4/UART_1.c ****         uint8 size;
1314:.\Generated_Source\PSoC4/UART_1.c **** 
1315:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1316:.\Generated_Source\PSoC4/UART_1.c **** 
1317:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Tx interrupt. */
1318:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
1319:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1320:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableTxInt();
1321:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1322:.\Generated_Source\PSoC4/UART_1.c **** 
1323:.\Generated_Source\PSoC4/UART_1.c ****             if(UART_1_txBufferRead == UART_1_txBufferWrite)
1324:.\Generated_Source\PSoC4/UART_1.c ****             {
1325:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
1326:.\Generated_Source\PSoC4/UART_1.c ****             }
1327:.\Generated_Source\PSoC4/UART_1.c ****             else if(UART_1_txBufferRead < UART_1_txBufferWrite)
1328:.\Generated_Source\PSoC4/UART_1.c ****             {
1329:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_txBufferWrite - UART_1_txBufferRead);
1330:.\Generated_Source\PSoC4/UART_1.c ****             }
1331:.\Generated_Source\PSoC4/UART_1.c ****             else
1332:.\Generated_Source\PSoC4/UART_1.c ****             {
1333:.\Generated_Source\PSoC4/UART_1.c ****                 size = (UART_1_TXBUFFERSIZE - UART_1_txBufferRead) + UART_1_txBufferWrite;
1334:.\Generated_Source\PSoC4/UART_1.c ****             }
1335:.\Generated_Source\PSoC4/UART_1.c **** 
1336:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Tx interrupt. */
1337:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1338:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableTxInt();
1339:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1340:.\Generated_Source\PSoC4/UART_1.c **** 
1341:.\Generated_Source\PSoC4/UART_1.c ****         #else /* UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1342:.\Generated_Source\PSoC4/UART_1.c **** 
1343:.\Generated_Source\PSoC4/UART_1.c ****             size = UART_1_TXSTATUS_REG;
 641              		.loc 1 1343 0
 642 0006 0F4A     		ldr	r2, .L52
 643 0008 FB1D     		add	r3, r7, #7
 644 000a 1278     		ldrb	r2, [r2]
 645 000c 1A70     		strb	r2, [r3]
1344:.\Generated_Source\PSoC4/UART_1.c **** 
1345:.\Generated_Source\PSoC4/UART_1.c ****             /* Is the fifo is full. */
1346:.\Generated_Source\PSoC4/UART_1.c ****             if((size & UART_1_TX_STS_FIFO_FULL) != 0u)
 646              		.loc 1 1346 0
 647 000e FB1D     		add	r3, r7, #7
 648 0010 1A78     		ldrb	r2, [r3]
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 36


 649 0012 0423     		mov	r3, #4
 650 0014 1340     		and	r3, r2
 651 0016 03D0     		beq	.L48
1347:.\Generated_Source\PSoC4/UART_1.c ****             {
1348:.\Generated_Source\PSoC4/UART_1.c ****                 size = UART_1_FIFO_LENGTH;
 652              		.loc 1 1348 0
 653 0018 FB1D     		add	r3, r7, #7
 654 001a 0422     		mov	r2, #4
 655 001c 1A70     		strb	r2, [r3]
 656 001e 0BE0     		b	.L49
 657              	.L48:
1349:.\Generated_Source\PSoC4/UART_1.c ****             }
1350:.\Generated_Source\PSoC4/UART_1.c ****             else if((size & UART_1_TX_STS_FIFO_EMPTY) != 0u)
 658              		.loc 1 1350 0
 659 0020 FB1D     		add	r3, r7, #7
 660 0022 1A78     		ldrb	r2, [r3]
 661 0024 0223     		mov	r3, #2
 662 0026 1340     		and	r3, r2
 663 0028 03D0     		beq	.L50
1351:.\Generated_Source\PSoC4/UART_1.c ****             {
1352:.\Generated_Source\PSoC4/UART_1.c ****                 size = 0u;
 664              		.loc 1 1352 0
 665 002a FB1D     		add	r3, r7, #7
 666 002c 0022     		mov	r2, #0
 667 002e 1A70     		strb	r2, [r3]
 668 0030 02E0     		b	.L49
 669              	.L50:
1353:.\Generated_Source\PSoC4/UART_1.c ****             }
1354:.\Generated_Source\PSoC4/UART_1.c ****             else
1355:.\Generated_Source\PSoC4/UART_1.c ****             {
1356:.\Generated_Source\PSoC4/UART_1.c ****                 /* We only know there is data in the fifo. */
1357:.\Generated_Source\PSoC4/UART_1.c ****                 size = 1u;
 670              		.loc 1 1357 0
 671 0032 FB1D     		add	r3, r7, #7
 672 0034 0122     		mov	r2, #1
 673 0036 1A70     		strb	r2, [r3]
 674              	.L49:
1358:.\Generated_Source\PSoC4/UART_1.c ****             }
1359:.\Generated_Source\PSoC4/UART_1.c **** 
1360:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1361:.\Generated_Source\PSoC4/UART_1.c **** 
1362:.\Generated_Source\PSoC4/UART_1.c ****         return(size);
 675              		.loc 1 1362 0
 676 0038 FB1D     		add	r3, r7, #7
 677 003a 1B78     		ldrb	r3, [r3]
1363:.\Generated_Source\PSoC4/UART_1.c ****     }
 678              		.loc 1 1363 0
 679 003c 181C     		mov	r0, r3
 680 003e BD46     		mov	sp, r7
 681 0040 02B0     		add	sp, sp, #8
 682              		@ sp needed
 683 0042 80BD     		pop	{r7, pc}
 684              	.L53:
 685              		.align	2
 686              	.L52:
 687 0044 60000F40 		.word	1074724960
 688              		.cfi_endproc
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 37


 689              	.LFE13:
 690              		.size	UART_1_GetTxBufferSize, .-UART_1_GetTxBufferSize
 691              		.section	.text.UART_1_ClearTxBuffer,"ax",%progbits
 692              		.align	2
 693              		.global	UART_1_ClearTxBuffer
 694              		.code	16
 695              		.thumb_func
 696              		.type	UART_1_ClearTxBuffer, %function
 697              	UART_1_ClearTxBuffer:
 698              	.LFB14:
1364:.\Generated_Source\PSoC4/UART_1.c **** 
1365:.\Generated_Source\PSoC4/UART_1.c **** 
1366:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1367:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_ClearTxBuffer
1368:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1369:.\Generated_Source\PSoC4/UART_1.c ****     *
1370:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1371:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the TX RAM buffer by setting the read and write pointers both to zero.
1372:.\Generated_Source\PSoC4/UART_1.c ****     *  Clears the hardware TX FIFO.  Any data present in the FIFO will not be sent.
1373:.\Generated_Source\PSoC4/UART_1.c ****     *
1374:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1375:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1376:.\Generated_Source\PSoC4/UART_1.c ****     *
1377:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1378:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1379:.\Generated_Source\PSoC4/UART_1.c ****     *
1380:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1381:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferWrite - cleared to zero.
1382:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_txBufferRead - cleared to zero.
1383:.\Generated_Source\PSoC4/UART_1.c ****     *
1384:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1385:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1386:.\Generated_Source\PSoC4/UART_1.c ****     *
1387:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1388:.\Generated_Source\PSoC4/UART_1.c ****     *  Setting the pointers to zero makes the system believe there is no data to
1389:.\Generated_Source\PSoC4/UART_1.c ****     *  read and writing will resume at address 0 overwriting any data that may have
1390:.\Generated_Source\PSoC4/UART_1.c ****     *  remained in the RAM.
1391:.\Generated_Source\PSoC4/UART_1.c ****     *
1392:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1393:.\Generated_Source\PSoC4/UART_1.c ****     *  Any received data not read from the RAM buffer will be lost when overwritten.
1394:.\Generated_Source\PSoC4/UART_1.c ****     *
1395:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1396:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_ClearTxBuffer(void) 
1397:.\Generated_Source\PSoC4/UART_1.c ****     {
 699              		.loc 1 1397 0
 700              		.cfi_startproc
 701 0000 90B5     		push	{r4, r7, lr}
 702              		.cfi_def_cfa_offset 12
 703              		.cfi_offset 4, -12
 704              		.cfi_offset 7, -8
 705              		.cfi_offset 14, -4
 706 0002 83B0     		sub	sp, sp, #12
 707              		.cfi_def_cfa_offset 24
 708 0004 00AF     		add	r7, sp, #0
 709              		.cfi_def_cfa_register 7
1398:.\Generated_Source\PSoC4/UART_1.c ****         uint8 enableInterrupts;
1399:.\Generated_Source\PSoC4/UART_1.c **** 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 38


1400:.\Generated_Source\PSoC4/UART_1.c ****         /* Enter critical section */
1401:.\Generated_Source\PSoC4/UART_1.c ****         enableInterrupts = CyEnterCriticalSection();
 710              		.loc 1 1401 0
 711 0006 FC1D     		add	r4, r7, #7
 712 0008 FFF7FEFF 		bl	CyEnterCriticalSection
 713 000c 031C     		mov	r3, r0
 714 000e 2370     		strb	r3, [r4]
1402:.\Generated_Source\PSoC4/UART_1.c ****         /* clear the HW FIFO */
1403:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG |=  UART_1_TX_FIFO_CLR;
 715              		.loc 1 1403 0
 716 0010 0B4B     		ldr	r3, .L55
 717 0012 0B4A     		ldr	r2, .L55
 718 0014 1278     		ldrb	r2, [r2]
 719 0016 D2B2     		uxtb	r2, r2
 720 0018 0121     		mov	r1, #1
 721 001a 0A43     		orr	r2, r1
 722 001c D2B2     		uxtb	r2, r2
 723 001e 1A70     		strb	r2, [r3]
1404:.\Generated_Source\PSoC4/UART_1.c ****         UART_1_TXDATA_AUX_CTL_REG &= (uint8)~UART_1_TX_FIFO_CLR;
 724              		.loc 1 1404 0
 725 0020 074B     		ldr	r3, .L55
 726 0022 074A     		ldr	r2, .L55
 727 0024 1278     		ldrb	r2, [r2]
 728 0026 D2B2     		uxtb	r2, r2
 729 0028 0121     		mov	r1, #1
 730 002a 8A43     		bic	r2, r1
 731 002c D2B2     		uxtb	r2, r2
 732 002e 1A70     		strb	r2, [r3]
1405:.\Generated_Source\PSoC4/UART_1.c ****         /* Exit critical section */
1406:.\Generated_Source\PSoC4/UART_1.c ****         CyExitCriticalSection(enableInterrupts);
 733              		.loc 1 1406 0
 734 0030 FB1D     		add	r3, r7, #7
 735 0032 1B78     		ldrb	r3, [r3]
 736 0034 181C     		mov	r0, r3
 737 0036 FFF7FEFF 		bl	CyExitCriticalSection
1407:.\Generated_Source\PSoC4/UART_1.c **** 
1408:.\Generated_Source\PSoC4/UART_1.c ****         #if(UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH)
1409:.\Generated_Source\PSoC4/UART_1.c **** 
1410:.\Generated_Source\PSoC4/UART_1.c ****             /* Disable Tx interrupt. */
1411:.\Generated_Source\PSoC4/UART_1.c ****             /* Protect variables that could change on interrupt. */
1412:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1413:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_DisableTxInt();
1414:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1415:.\Generated_Source\PSoC4/UART_1.c **** 
1416:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferRead = 0u;
1417:.\Generated_Source\PSoC4/UART_1.c ****             UART_1_txBufferWrite = 0u;
1418:.\Generated_Source\PSoC4/UART_1.c **** 
1419:.\Generated_Source\PSoC4/UART_1.c ****             /* Enable Tx interrupt. */
1420:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_TX_INTERRUPT_ENABLED)
1421:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_EnableTxInt();
1422:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_TX_INTERRUPT_ENABLED */
1423:.\Generated_Source\PSoC4/UART_1.c **** 
1424:.\Generated_Source\PSoC4/UART_1.c ****         #endif /* End UART_1_TXBUFFERSIZE > UART_1_FIFO_LENGTH */
1425:.\Generated_Source\PSoC4/UART_1.c ****     }
 738              		.loc 1 1425 0
 739 003a BD46     		mov	sp, r7
 740 003c 03B0     		add	sp, sp, #12
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 39


 741              		@ sp needed
 742 003e 90BD     		pop	{r4, r7, pc}
 743              	.L56:
 744              		.align	2
 745              	.L55:
 746 0040 90000F40 		.word	1074725008
 747              		.cfi_endproc
 748              	.LFE14:
 749              		.size	UART_1_ClearTxBuffer, .-UART_1_ClearTxBuffer
 750              		.section	.text.UART_1_SendBreak,"ax",%progbits
 751              		.align	2
 752              		.global	UART_1_SendBreak
 753              		.code	16
 754              		.thumb_func
 755              		.type	UART_1_SendBreak, %function
 756              	UART_1_SendBreak:
 757              	.LFB15:
1426:.\Generated_Source\PSoC4/UART_1.c **** 
1427:.\Generated_Source\PSoC4/UART_1.c **** 
1428:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1429:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SendBreak
1430:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1431:.\Generated_Source\PSoC4/UART_1.c ****     *
1432:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1433:.\Generated_Source\PSoC4/UART_1.c ****     *  Write a Break command to the UART
1434:.\Generated_Source\PSoC4/UART_1.c ****     *
1435:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1436:.\Generated_Source\PSoC4/UART_1.c ****     *  uint8 retMode:  Wait mode,
1437:.\Generated_Source\PSoC4/UART_1.c ****     *   0 - Initialize registers for Break, sends the Break signal and return
1438:.\Generated_Source\PSoC4/UART_1.c ****     *       imediately.
1439:.\Generated_Source\PSoC4/UART_1.c ****     *   1 - Wait until Break sending is complete, reinitialize registers to normal
1440:.\Generated_Source\PSoC4/UART_1.c ****     *       transmission mode then return.
1441:.\Generated_Source\PSoC4/UART_1.c ****     *   2 - Reinitialize registers to normal transmission mode then return.
1442:.\Generated_Source\PSoC4/UART_1.c ****     *   3 - both steps: 0 and 1
1443:.\Generated_Source\PSoC4/UART_1.c ****     *       init registers for Break, send Break signal
1444:.\Generated_Source\PSoC4/UART_1.c ****     *       wait until Break sending is complete, reinit registers to normal
1445:.\Generated_Source\PSoC4/UART_1.c ****     *       transmission mode then return.
1446:.\Generated_Source\PSoC4/UART_1.c ****     *
1447:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1448:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1449:.\Generated_Source\PSoC4/UART_1.c ****     *
1450:.\Generated_Source\PSoC4/UART_1.c ****     * Global Variables:
1451:.\Generated_Source\PSoC4/UART_1.c ****     *  UART_1_initVar - checked to identify that the component has been
1452:.\Generated_Source\PSoC4/UART_1.c ****     *     initialized.
1453:.\Generated_Source\PSoC4/UART_1.c ****     *  tx_period - static variable, used for keeping TX period configuration.
1454:.\Generated_Source\PSoC4/UART_1.c ****     *
1455:.\Generated_Source\PSoC4/UART_1.c ****     * Reentrant:
1456:.\Generated_Source\PSoC4/UART_1.c ****     *  No.
1457:.\Generated_Source\PSoC4/UART_1.c ****     *
1458:.\Generated_Source\PSoC4/UART_1.c ****     * Theory:
1459:.\Generated_Source\PSoC4/UART_1.c ****     *  SendBreak function initializes registers to send 13-bit break signal. It is
1460:.\Generated_Source\PSoC4/UART_1.c ****     *  important to return the registers configuration to normal for continue 8-bit
1461:.\Generated_Source\PSoC4/UART_1.c ****     *  operation.
1462:.\Generated_Source\PSoC4/UART_1.c ****     *  Trere are 3 variants for this API usage:
1463:.\Generated_Source\PSoC4/UART_1.c ****     *  1) SendBreak(3) - function will send the Break signal and take care on the
1464:.\Generated_Source\PSoC4/UART_1.c ****     *     configuration returning. Funcition will block CPU untill transmition
1465:.\Generated_Source\PSoC4/UART_1.c ****     *     complete.
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 40


1466:.\Generated_Source\PSoC4/UART_1.c ****     *  2) User may want to use bloking time if UART configured to the low speed
1467:.\Generated_Source\PSoC4/UART_1.c ****     *     operation
1468:.\Generated_Source\PSoC4/UART_1.c ****     *     Emample for this case:
1469:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1470:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1471:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(1);     - complete Break operation
1472:.\Generated_Source\PSoC4/UART_1.c ****     *  3) Same to 2) but user may want to init and use the interrupt for complete
1473:.\Generated_Source\PSoC4/UART_1.c ****     *     break operation.
1474:.\Generated_Source\PSoC4/UART_1.c ****     *     Example for this case:
1475:.\Generated_Source\PSoC4/UART_1.c ****     *     Init TX interrupt whith "TX - On TX Complete" parameter
1476:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(0);     - init Break signal transmition
1477:.\Generated_Source\PSoC4/UART_1.c ****     *         Add your code here to use CPU time
1478:.\Generated_Source\PSoC4/UART_1.c ****     *     When interrupt appear with UART_TX_STS_COMPLETE status:
1479:.\Generated_Source\PSoC4/UART_1.c ****     *     SendBreak(2);     - complete Break operation
1480:.\Generated_Source\PSoC4/UART_1.c ****     *
1481:.\Generated_Source\PSoC4/UART_1.c ****     * Side Effects:
1482:.\Generated_Source\PSoC4/UART_1.c ****     *   Uses static variable to keep registers configuration.
1483:.\Generated_Source\PSoC4/UART_1.c ****     *
1484:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1485:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SendBreak(uint8 retMode) 
1486:.\Generated_Source\PSoC4/UART_1.c ****     {
 758              		.loc 1 1486 0
 759              		.cfi_startproc
 760 0000 80B5     		push	{r7, lr}
 761              		.cfi_def_cfa_offset 8
 762              		.cfi_offset 7, -8
 763              		.cfi_offset 14, -4
 764 0002 84B0     		sub	sp, sp, #16
 765              		.cfi_def_cfa_offset 24
 766 0004 00AF     		add	r7, sp, #0
 767              		.cfi_def_cfa_register 7
 768 0006 021C     		mov	r2, r0
 769 0008 FB1D     		add	r3, r7, #7
 770 000a 1A70     		strb	r2, [r3]
1487:.\Generated_Source\PSoC4/UART_1.c **** 
1488:.\Generated_Source\PSoC4/UART_1.c ****         /* If not Initialized then skip this function*/
1489:.\Generated_Source\PSoC4/UART_1.c ****         if(UART_1_initVar != 0u)
 771              		.loc 1 1489 0
 772 000c 254B     		ldr	r3, .L65
 773 000e 1B78     		ldrb	r3, [r3]
 774 0010 002B     		cmp	r3, #0
 775 0012 43D0     		beq	.L57
 776              	.LBB2:
1490:.\Generated_Source\PSoC4/UART_1.c ****         {
1491:.\Generated_Source\PSoC4/UART_1.c ****             /*Set the Counter to 13-bits and transmit a 00 byte*/
1492:.\Generated_Source\PSoC4/UART_1.c ****             /*When that is done then reset the counter value back*/
1493:.\Generated_Source\PSoC4/UART_1.c ****             uint8 tmpStat;
1494:.\Generated_Source\PSoC4/UART_1.c **** 
1495:.\Generated_Source\PSoC4/UART_1.c ****             #if(UART_1_HD_ENABLED) /* Half Duplex mode*/
1496:.\Generated_Source\PSoC4/UART_1.c **** 
1497:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
1498:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT ) )
1499:.\Generated_Source\PSoC4/UART_1.c ****                 {
1500:.\Generated_Source\PSoC4/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - sends break bits in HD mode*/
1501:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1502:.\Generated_Source\PSoC4/UART_1.c ****                                                           UART_1_CTRL_HD_SEND_BREAK);
1503:.\Generated_Source\PSoC4/UART_1.c ****                     /* Send zeros*/
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 41


1504:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
1505:.\Generated_Source\PSoC4/UART_1.c **** 
1506:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit starts*/
1507:.\Generated_Source\PSoC4/UART_1.c ****                     {
1508:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1509:.\Generated_Source\PSoC4/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
1510:.\Generated_Source\PSoC4/UART_1.c ****                 }
1511:.\Generated_Source\PSoC4/UART_1.c **** 
1512:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1513:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1514:.\Generated_Source\PSoC4/UART_1.c ****                 {
1515:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit complete*/
1516:.\Generated_Source\PSoC4/UART_1.c ****                     {
1517:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
1518:.\Generated_Source\PSoC4/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
1519:.\Generated_Source\PSoC4/UART_1.c ****                 }
1520:.\Generated_Source\PSoC4/UART_1.c **** 
1521:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
1522:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_REINIT) ||
1523:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1524:.\Generated_Source\PSoC4/UART_1.c ****                 {
1525:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1526:.\Generated_Source\PSoC4/UART_1.c ****                                                   (uint8)~UART_1_CTRL_HD_SEND_BREAK);
1527:.\Generated_Source\PSoC4/UART_1.c ****                 }
1528:.\Generated_Source\PSoC4/UART_1.c **** 
1529:.\Generated_Source\PSoC4/UART_1.c ****             #else /* UART_1_HD_ENABLED Full Duplex mode */
1530:.\Generated_Source\PSoC4/UART_1.c **** 
1531:.\Generated_Source\PSoC4/UART_1.c ****                 static uint8 tx_period;
1532:.\Generated_Source\PSoC4/UART_1.c **** 
1533:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_SEND_BREAK) ||
 777              		.loc 1 1533 0
 778 0014 FB1D     		add	r3, r7, #7
 779 0016 1B78     		ldrb	r3, [r3]
 780 0018 002B     		cmp	r3, #0
 781 001a 03D0     		beq	.L59
 782              		.loc 1 1533 0 is_stmt 0 discriminator 1
 783 001c FB1D     		add	r3, r7, #7
 784 001e 1B78     		ldrb	r3, [r3]
 785 0020 032B     		cmp	r3, #3
 786 0022 15D1     		bne	.L60
 787              	.L59:
1534:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1535:.\Generated_Source\PSoC4/UART_1.c ****                 {
1536:.\Generated_Source\PSoC4/UART_1.c ****                     /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex 
1537:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1538:.\Generated_Source\PSoC4/UART_1.c ****                                         (UART_1_PARITY_TYPE_SW != 0u) )
1539:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1540:.\Generated_Source\PSoC4/UART_1.c ****                                                               UART_1_CTRL_HD_SEND_BREAK);
1541:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB  */
1542:.\Generated_Source\PSoC4/UART_1.c **** 
1543:.\Generated_Source\PSoC4/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1544:.\Generated_Source\PSoC4/UART_1.c ****                         tx_period = UART_1_TXBITCLKTX_COMPLETE_REG;
 788              		.loc 1 1544 0 is_stmt 1
 789 0024 204B     		ldr	r3, .L65+4
 790 0026 1B78     		ldrb	r3, [r3]
 791 0028 DAB2     		uxtb	r2, r3
 792 002a 204B     		ldr	r3, .L65+8
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 42


 793 002c 1A70     		strb	r2, [r3]
1545:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = UART_1_TXBITCTR_BREAKBITS;
 794              		.loc 1 1545 0
 795 002e 1E4B     		ldr	r3, .L65+4
 796 0030 6722     		mov	r2, #103
 797 0032 1A70     		strb	r2, [r3]
1546:.\Generated_Source\PSoC4/UART_1.c ****                     #else
1547:.\Generated_Source\PSoC4/UART_1.c ****                         tx_period = UART_1_TXBITCTR_PERIOD_REG;
1548:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = UART_1_TXBITCTR_BREAKBITS8X;
1549:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1550:.\Generated_Source\PSoC4/UART_1.c **** 
1551:.\Generated_Source\PSoC4/UART_1.c ****                     /* Send zeros*/
1552:.\Generated_Source\PSoC4/UART_1.c ****                     UART_1_TXDATA_REG = 0u;
 798              		.loc 1 1552 0
 799 0034 1E4B     		ldr	r3, .L65+12
 800 0036 0022     		mov	r2, #0
 801 0038 1A70     		strb	r2, [r3]
 802              	.L61:
1553:.\Generated_Source\PSoC4/UART_1.c **** 
1554:.\Generated_Source\PSoC4/UART_1.c ****                     do /* wait until transmit starts */
1555:.\Generated_Source\PSoC4/UART_1.c ****                     {
1556:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 803              		.loc 1 1556 0 discriminator 1
 804 003a 1E4A     		ldr	r2, .L65+16
 805 003c 3B1C     		mov	r3, r7
 806 003e 0F33     		add	r3, r3, #15
 807 0040 1278     		ldrb	r2, [r2]
 808 0042 1A70     		strb	r2, [r3]
1557:.\Generated_Source\PSoC4/UART_1.c ****                     }while((tmpStat & UART_1_TX_STS_FIFO_EMPTY) != 0u);
 809              		.loc 1 1557 0 discriminator 1
 810 0044 3B1C     		mov	r3, r7
 811 0046 0F33     		add	r3, r3, #15
 812 0048 1A78     		ldrb	r2, [r3]
 813 004a 0223     		mov	r3, #2
 814 004c 1340     		and	r3, r2
 815 004e F4D1     		bne	.L61
 816              	.L60:
1558:.\Generated_Source\PSoC4/UART_1.c ****                 }
1559:.\Generated_Source\PSoC4/UART_1.c **** 
1560:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 817              		.loc 1 1560 0
 818 0050 FB1D     		add	r3, r7, #7
 819 0052 1B78     		ldrb	r3, [r3]
 820 0054 012B     		cmp	r3, #1
 821 0056 03D0     		beq	.L62
 822              		.loc 1 1560 0 is_stmt 0 discriminator 1
 823 0058 FB1D     		add	r3, r7, #7
 824 005a 1B78     		ldrb	r3, [r3]
 825 005c 032B     		cmp	r3, #3
 826 005e 0DD1     		bne	.L63
 827              	.L62:
1561:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1562:.\Generated_Source\PSoC4/UART_1.c ****                 {
1563:.\Generated_Source\PSoC4/UART_1.c ****                     do /*wait until transmit complete*/
1564:.\Generated_Source\PSoC4/UART_1.c ****                     {
1565:.\Generated_Source\PSoC4/UART_1.c ****                         tmpStat = UART_1_TXSTATUS_REG;
 828              		.loc 1 1565 0 is_stmt 1 discriminator 1
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 43


 829 0060 144A     		ldr	r2, .L65+16
 830 0062 3B1C     		mov	r3, r7
 831 0064 0F33     		add	r3, r3, #15
 832 0066 1278     		ldrb	r2, [r2]
 833 0068 1A70     		strb	r2, [r3]
1566:.\Generated_Source\PSoC4/UART_1.c ****                     }while(((uint8)~tmpStat & UART_1_TX_STS_COMPLETE) != 0u);
 834              		.loc 1 1566 0 discriminator 1
 835 006a 3B1C     		mov	r3, r7
 836 006c 0F33     		add	r3, r3, #15
 837 006e 1B78     		ldrb	r3, [r3]
 838 0070 DB43     		mvn	r3, r3
 839 0072 DBB2     		uxtb	r3, r3
 840 0074 1A1C     		mov	r2, r3
 841 0076 0123     		mov	r3, #1
 842 0078 1340     		and	r3, r2
 843 007a F1D1     		bne	.L62
 844              	.L63:
1567:.\Generated_Source\PSoC4/UART_1.c ****                 }
1568:.\Generated_Source\PSoC4/UART_1.c **** 
1569:.\Generated_Source\PSoC4/UART_1.c ****                 if( (retMode == UART_1_WAIT_FOR_COMPLETE_REINIT) ||
 845              		.loc 1 1569 0
 846 007c FB1D     		add	r3, r7, #7
 847 007e 1B78     		ldrb	r3, [r3]
 848 0080 012B     		cmp	r3, #1
 849 0082 07D0     		beq	.L64
 850              		.loc 1 1569 0 is_stmt 0 discriminator 1
 851 0084 FB1D     		add	r3, r7, #7
 852 0086 1B78     		ldrb	r3, [r3]
 853 0088 022B     		cmp	r3, #2
 854 008a 03D0     		beq	.L64
1570:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_REINIT) ||
 855              		.loc 1 1570 0 is_stmt 1
 856 008c FB1D     		add	r3, r7, #7
 857 008e 1B78     		ldrb	r3, [r3]
 858 0090 032B     		cmp	r3, #3
 859 0092 03D1     		bne	.L57
 860              	.L64:
1571:.\Generated_Source\PSoC4/UART_1.c ****                     (retMode == UART_1_SEND_WAIT_REINIT) )
1572:.\Generated_Source\PSoC4/UART_1.c ****                 {
1573:.\Generated_Source\PSoC4/UART_1.c **** 
1574:.\Generated_Source\PSoC4/UART_1.c ****                     #if(UART_1_TXCLKGEN_DP)
1575:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCLKTX_COMPLETE_REG = tx_period;
 861              		.loc 1 1575 0
 862 0094 044B     		ldr	r3, .L65+4
 863 0096 054A     		ldr	r2, .L65+8
 864 0098 1278     		ldrb	r2, [r2]
 865 009a 1A70     		strb	r2, [r3]
 866              	.L57:
 867              	.LBE2:
1576:.\Generated_Source\PSoC4/UART_1.c ****                     #else
1577:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_TXBITCTR_PERIOD_REG = tx_period;
1578:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_TXCLKGEN_DP */
1579:.\Generated_Source\PSoC4/UART_1.c **** 
1580:.\Generated_Source\PSoC4/UART_1.c ****                     #if( (UART_1_PARITY_TYPE != UART_1__B_UART__NONE_REVB) || \
1581:.\Generated_Source\PSoC4/UART_1.c ****                          (UART_1_PARITY_TYPE_SW != 0u) )
1582:.\Generated_Source\PSoC4/UART_1.c ****                         UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1583:.\Generated_Source\PSoC4/UART_1.c ****                                                       (uint8)~UART_1_CTRL_HD_SEND_BREAK);
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 44


1584:.\Generated_Source\PSoC4/UART_1.c ****                     #endif /* End UART_1_PARITY_TYPE != NONE */
1585:.\Generated_Source\PSoC4/UART_1.c ****                 }
1586:.\Generated_Source\PSoC4/UART_1.c ****             #endif    /* End UART_1_HD_ENABLED */
1587:.\Generated_Source\PSoC4/UART_1.c ****         }
1588:.\Generated_Source\PSoC4/UART_1.c ****     }
 868              		.loc 1 1588 0
 869 009c BD46     		mov	sp, r7
 870 009e 04B0     		add	sp, sp, #16
 871              		@ sp needed
 872 00a0 80BD     		pop	{r7, pc}
 873              	.L66:
 874 00a2 C046     		.align	2
 875              	.L65:
 876 00a4 00000000 		.word	UART_1_initVar
 877 00a8 31000F40 		.word	1074724913
 878 00ac 01000000 		.word	tx_period.4771
 879 00b0 40000F40 		.word	1074724928
 880 00b4 60000F40 		.word	1074724960
 881              		.cfi_endproc
 882              	.LFE15:
 883              		.size	UART_1_SendBreak, .-UART_1_SendBreak
 884              		.section	.text.UART_1_SetTxAddressMode,"ax",%progbits
 885              		.align	2
 886              		.global	UART_1_SetTxAddressMode
 887              		.code	16
 888              		.thumb_func
 889              		.type	UART_1_SetTxAddressMode, %function
 890              	UART_1_SetTxAddressMode:
 891              	.LFB16:
1589:.\Generated_Source\PSoC4/UART_1.c **** 
1590:.\Generated_Source\PSoC4/UART_1.c **** 
1591:.\Generated_Source\PSoC4/UART_1.c ****     /*******************************************************************************
1592:.\Generated_Source\PSoC4/UART_1.c ****     * Function Name: UART_1_SetTxAddressMode
1593:.\Generated_Source\PSoC4/UART_1.c ****     ********************************************************************************
1594:.\Generated_Source\PSoC4/UART_1.c ****     *
1595:.\Generated_Source\PSoC4/UART_1.c ****     * Summary:
1596:.\Generated_Source\PSoC4/UART_1.c ****     *  Set the transmit addressing mode
1597:.\Generated_Source\PSoC4/UART_1.c ****     *
1598:.\Generated_Source\PSoC4/UART_1.c ****     * Parameters:
1599:.\Generated_Source\PSoC4/UART_1.c ****     *  addressMode: 0 -> Space
1600:.\Generated_Source\PSoC4/UART_1.c ****     *               1 -> Mark
1601:.\Generated_Source\PSoC4/UART_1.c ****     *
1602:.\Generated_Source\PSoC4/UART_1.c ****     * Return:
1603:.\Generated_Source\PSoC4/UART_1.c ****     *  None.
1604:.\Generated_Source\PSoC4/UART_1.c ****     *
1605:.\Generated_Source\PSoC4/UART_1.c ****     *******************************************************************************/
1606:.\Generated_Source\PSoC4/UART_1.c ****     void UART_1_SetTxAddressMode(uint8 addressMode) 
1607:.\Generated_Source\PSoC4/UART_1.c ****     {
 892              		.loc 1 1607 0
 893              		.cfi_startproc
 894 0000 80B5     		push	{r7, lr}
 895              		.cfi_def_cfa_offset 8
 896              		.cfi_offset 7, -8
 897              		.cfi_offset 14, -4
 898 0002 82B0     		sub	sp, sp, #8
 899              		.cfi_def_cfa_offset 16
 900 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 45


 901              		.cfi_def_cfa_register 7
 902 0006 021C     		mov	r2, r0
 903 0008 FB1D     		add	r3, r7, #7
 904 000a 1A70     		strb	r2, [r3]
1608:.\Generated_Source\PSoC4/UART_1.c ****         /* Mark/Space sending enable*/
1609:.\Generated_Source\PSoC4/UART_1.c ****         if(addressMode != 0u)
1610:.\Generated_Source\PSoC4/UART_1.c ****         {
1611:.\Generated_Source\PSoC4/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1612:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() |
1613:.\Generated_Source\PSoC4/UART_1.c ****                                                       UART_1_CTRL_MARK);
1614:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1615:.\Generated_Source\PSoC4/UART_1.c ****         }
1616:.\Generated_Source\PSoC4/UART_1.c ****         else
1617:.\Generated_Source\PSoC4/UART_1.c ****         {
1618:.\Generated_Source\PSoC4/UART_1.c ****             #if( UART_1_CONTROL_REG_REMOVED == 0u )
1619:.\Generated_Source\PSoC4/UART_1.c ****                 UART_1_WriteControlRegister(UART_1_ReadControlRegister() &
1620:.\Generated_Source\PSoC4/UART_1.c ****                                                     (uint8)~UART_1_CTRL_MARK);
1621:.\Generated_Source\PSoC4/UART_1.c ****             #endif /* End UART_1_CONTROL_REG_REMOVED == 0u */
1622:.\Generated_Source\PSoC4/UART_1.c ****         }
1623:.\Generated_Source\PSoC4/UART_1.c ****     }
 905              		.loc 1 1623 0
 906 000c BD46     		mov	sp, r7
 907 000e 02B0     		add	sp, sp, #8
 908              		@ sp needed
 909 0010 80BD     		pop	{r7, pc}
 910              		.cfi_endproc
 911              	.LFE16:
 912              		.size	UART_1_SetTxAddressMode, .-UART_1_SetTxAddressMode
 913 0012 C046     		.bss
 914              	tx_period.4771:
 915 0001 00       		.space	1
 916              		.text
 917              	.Letext0:
 918              		.file 2 ".\\Generated_Source\\PSoC4\\cytypes.h"
 919              		.section	.debug_info,"",%progbits
 920              	.Ldebug_info0:
 921 0000 71030000 		.4byte	0x371
 922 0004 0400     		.2byte	0x4
 923 0006 00000000 		.4byte	.Ldebug_abbrev0
 924 000a 04       		.byte	0x4
 925 000b 01       		.uleb128 0x1
 926 000c A6000000 		.4byte	.LASF45
 927 0010 01       		.byte	0x1
 928 0011 1F030000 		.4byte	.LASF46
 929 0015 0C020000 		.4byte	.LASF47
 930 0019 00000000 		.4byte	.Ldebug_ranges0+0
 931 001d 00000000 		.4byte	0
 932 0021 00000000 		.4byte	.Ldebug_line0
 933 0025 02       		.uleb128 0x2
 934 0026 01       		.byte	0x1
 935 0027 06       		.byte	0x6
 936 0028 41030000 		.4byte	.LASF0
 937 002c 02       		.uleb128 0x2
 938 002d 01       		.byte	0x1
 939 002e 08       		.byte	0x8
 940 002f 95010000 		.4byte	.LASF1
 941 0033 02       		.uleb128 0x2
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 46


 942 0034 02       		.byte	0x2
 943 0035 05       		.byte	0x5
 944 0036 B1010000 		.4byte	.LASF2
 945 003a 02       		.uleb128 0x2
 946 003b 02       		.byte	0x2
 947 003c 07       		.byte	0x7
 948 003d 5A000000 		.4byte	.LASF3
 949 0041 02       		.uleb128 0x2
 950 0042 04       		.byte	0x4
 951 0043 05       		.byte	0x5
 952 0044 EE020000 		.4byte	.LASF4
 953 0048 02       		.uleb128 0x2
 954 0049 04       		.byte	0x4
 955 004a 07       		.byte	0x7
 956 004b 5A010000 		.4byte	.LASF5
 957 004f 02       		.uleb128 0x2
 958 0050 08       		.byte	0x8
 959 0051 05       		.byte	0x5
 960 0052 00000000 		.4byte	.LASF6
 961 0056 02       		.uleb128 0x2
 962 0057 08       		.byte	0x8
 963 0058 07       		.byte	0x7
 964 0059 F5010000 		.4byte	.LASF7
 965 005d 03       		.uleb128 0x3
 966 005e 04       		.byte	0x4
 967 005f 05       		.byte	0x5
 968 0060 696E7400 		.ascii	"int\000"
 969 0064 02       		.uleb128 0x2
 970 0065 04       		.byte	0x4
 971 0066 07       		.byte	0x7
 972 0067 D1010000 		.4byte	.LASF8
 973 006b 04       		.uleb128 0x4
 974 006c 6C010000 		.4byte	.LASF9
 975 0070 02       		.byte	0x2
 976 0071 A1       		.byte	0xa1
 977 0072 2C000000 		.4byte	0x2c
 978 0076 04       		.uleb128 0x4
 979 0077 BB010000 		.4byte	.LASF10
 980 007b 02       		.byte	0x2
 981 007c A2       		.byte	0xa2
 982 007d 3A000000 		.4byte	0x3a
 983 0081 02       		.uleb128 0x2
 984 0082 04       		.byte	0x4
 985 0083 04       		.byte	0x4
 986 0084 A0000000 		.4byte	.LASF11
 987 0088 02       		.uleb128 0x2
 988 0089 08       		.byte	0x8
 989 008a 04       		.byte	0x4
 990 008b A3010000 		.4byte	.LASF12
 991 008f 04       		.uleb128 0x4
 992 0090 9E020000 		.4byte	.LASF13
 993 0094 02       		.byte	0x2
 994 0095 B2       		.byte	0xb2
 995 0096 9A000000 		.4byte	0x9a
 996 009a 02       		.uleb128 0x2
 997 009b 01       		.byte	0x1
 998 009c 08       		.byte	0x8
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 47


 999 009d B9020000 		.4byte	.LASF14
 1000 00a1 05       		.uleb128 0x5
 1001 00a2 2E010000 		.4byte	.LASF15
 1002 00a6 02       		.byte	0x2
 1003 00a7 4B01     		.2byte	0x14b
 1004 00a9 AD000000 		.4byte	0xad
 1005 00ad 06       		.uleb128 0x6
 1006 00ae 6B000000 		.4byte	0x6b
 1007 00b2 02       		.uleb128 0x2
 1008 00b3 04       		.byte	0x4
 1009 00b4 07       		.byte	0x7
 1010 00b5 95020000 		.4byte	.LASF16
 1011 00b9 07       		.uleb128 0x7
 1012 00ba 1A000000 		.4byte	.LASF17
 1013 00be 01       		.byte	0x1
 1014 00bf 49       		.byte	0x49
 1015 00c0 00000000 		.4byte	.LFB0
 1016 00c4 24000000 		.4byte	.LFE0-.LFB0
 1017 00c8 01       		.uleb128 0x1
 1018 00c9 9C       		.byte	0x9c
 1019 00ca 08       		.uleb128 0x8
 1020 00cb 0E000000 		.4byte	.LASF18
 1021 00cf 01       		.byte	0x1
 1022 00d0 65       		.byte	0x65
 1023 00d1 00000000 		.4byte	.LFB1
 1024 00d5 28000000 		.4byte	.LFE1-.LFB1
 1025 00d9 01       		.uleb128 0x1
 1026 00da 9C       		.byte	0x9c
 1027 00db 09       		.uleb128 0x9
 1028 00dc 11030000 		.4byte	.LASF19
 1029 00e0 01       		.byte	0x1
 1030 00e1 AE       		.byte	0xae
 1031 00e2 00000000 		.4byte	.LFB2
 1032 00e6 38000000 		.4byte	.LFE2-.LFB2
 1033 00ea 01       		.uleb128 0x1
 1034 00eb 9C       		.byte	0x9c
 1035 00ec FF000000 		.4byte	0xff
 1036 00f0 0A       		.uleb128 0xa
 1037 00f1 84010000 		.4byte	.LASF21
 1038 00f5 01       		.byte	0x1
 1039 00f6 B0       		.byte	0xb0
 1040 00f7 6B000000 		.4byte	0x6b
 1041 00fb 02       		.uleb128 0x2
 1042 00fc 91       		.byte	0x91
 1043 00fd 6F       		.sleb128 -17
 1044 00fe 00       		.byte	0
 1045 00ff 09       		.uleb128 0x9
 1046 0100 4E010000 		.4byte	.LASF20
 1047 0104 01       		.byte	0x1
 1048 0105 E3       		.byte	0xe3
 1049 0106 00000000 		.4byte	.LFB3
 1050 010a 38000000 		.4byte	.LFE3-.LFB3
 1051 010e 01       		.uleb128 0x1
 1052 010f 9C       		.byte	0x9c
 1053 0110 23010000 		.4byte	0x123
 1054 0114 0A       		.uleb128 0xa
 1055 0115 84010000 		.4byte	.LASF21
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 48


 1056 0119 01       		.byte	0x1
 1057 011a E5       		.byte	0xe5
 1058 011b 6B000000 		.4byte	0x6b
 1059 011f 02       		.uleb128 0x2
 1060 0120 91       		.byte	0x91
 1061 0121 6F       		.sleb128 -17
 1062 0122 00       		.byte	0
 1063 0123 0B       		.uleb128 0xb
 1064 0124 33010000 		.4byte	.LASF28
 1065 0128 01       		.byte	0x1
 1066 0129 1901     		.2byte	0x119
 1067 012b 6B000000 		.4byte	0x6b
 1068 012f 00000000 		.4byte	.LFB4
 1069 0133 0C000000 		.4byte	.LFE4-.LFB4
 1070 0137 01       		.uleb128 0x1
 1071 0138 9C       		.byte	0x9c
 1072 0139 0C       		.uleb128 0xc
 1073 013a 27000000 		.4byte	.LASF22
 1074 013e 01       		.byte	0x1
 1075 013f 3101     		.2byte	0x131
 1076 0141 00000000 		.4byte	.LFB5
 1077 0145 12000000 		.4byte	.LFE5-.LFB5
 1078 0149 01       		.uleb128 0x1
 1079 014a 9C       		.byte	0x9c
 1080 014b 5F010000 		.4byte	0x15f
 1081 014f 0D       		.uleb128 0xd
 1082 0150 72010000 		.4byte	.LASF24
 1083 0154 01       		.byte	0x1
 1084 0155 3101     		.2byte	0x131
 1085 0157 6B000000 		.4byte	0x6b
 1086 015b 02       		.uleb128 0x2
 1087 015c 91       		.byte	0x91
 1088 015d 77       		.sleb128 -9
 1089 015e 00       		.byte	0
 1090 015f 0C       		.uleb128 0xc
 1091 0160 F7020000 		.4byte	.LASF23
 1092 0164 01       		.byte	0x1
 1093 0165 C803     		.2byte	0x3c8
 1094 0167 00000000 		.4byte	.LFB6
 1095 016b 20000000 		.4byte	.LFE6-.LFB6
 1096 016f 01       		.uleb128 0x1
 1097 0170 9C       		.byte	0x9c
 1098 0171 85010000 		.4byte	0x185
 1099 0175 0D       		.uleb128 0xd
 1100 0176 AA010000 		.4byte	.LASF25
 1101 017a 01       		.byte	0x1
 1102 017b C803     		.2byte	0x3c8
 1103 017d 6B000000 		.4byte	0x6b
 1104 0181 02       		.uleb128 0x2
 1105 0182 91       		.byte	0x91
 1106 0183 77       		.sleb128 -9
 1107 0184 00       		.byte	0
 1108 0185 0C       		.uleb128 0xc
 1109 0186 C6020000 		.4byte	.LASF26
 1110 018a 01       		.byte	0x1
 1111 018b EA03     		.2byte	0x3ea
 1112 018d 00000000 		.4byte	.LFB7
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 49


 1113 0191 2C000000 		.4byte	.LFE7-.LFB7
 1114 0195 01       		.uleb128 0x1
 1115 0196 9C       		.byte	0x9c
 1116 0197 AB010000 		.4byte	0x1ab
 1117 019b 0D       		.uleb128 0xd
 1118 019c A4020000 		.4byte	.LASF27
 1119 01a0 01       		.byte	0x1
 1120 01a1 EA03     		.2byte	0x3ea
 1121 01a3 6B000000 		.4byte	0x6b
 1122 01a7 02       		.uleb128 0x2
 1123 01a8 91       		.byte	0x91
 1124 01a9 77       		.sleb128 -9
 1125 01aa 00       		.byte	0
 1126 01ab 0B       		.uleb128 0xb
 1127 01ac 85000000 		.4byte	.LASF29
 1128 01b0 01       		.byte	0x1
 1129 01b1 2E04     		.2byte	0x42e
 1130 01b3 6B000000 		.4byte	0x6b
 1131 01b7 00000000 		.4byte	.LFB8
 1132 01bb 14000000 		.4byte	.LFE8-.LFB8
 1133 01bf 01       		.uleb128 0x1
 1134 01c0 9C       		.byte	0x9c
 1135 01c1 0C       		.uleb128 0xc
 1136 01c2 C2010000 		.4byte	.LASF30
 1137 01c6 01       		.byte	0x1
 1138 01c7 5204     		.2byte	0x452
 1139 01c9 00000000 		.4byte	.LFB9
 1140 01cd 34000000 		.4byte	.LFE9-.LFB9
 1141 01d1 01       		.uleb128 0x1
 1142 01d2 9C       		.byte	0x9c
 1143 01d3 E7010000 		.4byte	0x1e7
 1144 01d7 0D       		.uleb128 0xd
 1145 01d8 A4020000 		.4byte	.LASF27
 1146 01dc 01       		.byte	0x1
 1147 01dd 5204     		.2byte	0x452
 1148 01df 6B000000 		.4byte	0x6b
 1149 01e3 02       		.uleb128 0x2
 1150 01e4 91       		.byte	0x91
 1151 01e5 77       		.sleb128 -9
 1152 01e6 00       		.byte	0
 1153 01e7 0E       		.uleb128 0xe
 1154 01e8 4D030000 		.4byte	.LASF31
 1155 01ec 01       		.byte	0x1
 1156 01ed AE04     		.2byte	0x4ae
 1157 01ef 00000000 		.4byte	.LFB10
 1158 01f3 54000000 		.4byte	.LFE10-.LFB10
 1159 01f7 01       		.uleb128 0x1
 1160 01f8 9C       		.byte	0x9c
 1161 01f9 1C020000 		.4byte	0x21c
 1162 01fd 0D       		.uleb128 0xd
 1163 01fe 99000000 		.4byte	.LASF32
 1164 0202 01       		.byte	0x1
 1165 0203 AE04     		.2byte	0x4ae
 1166 0205 1C020000 		.4byte	0x21c
 1167 0209 02       		.uleb128 0x2
 1168 020a 91       		.byte	0x91
 1169 020b 6C       		.sleb128 -20
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 50


 1170 020c 0F       		.uleb128 0xf
 1171 020d 63030000 		.4byte	.LASF33
 1172 0211 01       		.byte	0x1
 1173 0212 B004     		.2byte	0x4b0
 1174 0214 76000000 		.4byte	0x76
 1175 0218 02       		.uleb128 0x2
 1176 0219 91       		.byte	0x91
 1177 021a 76       		.sleb128 -10
 1178 021b 00       		.byte	0
 1179 021c 10       		.uleb128 0x10
 1180 021d 04       		.byte	0x4
 1181 021e 22020000 		.4byte	0x222
 1182 0222 11       		.uleb128 0x11
 1183 0223 8F000000 		.4byte	0x8f
 1184 0227 0E       		.uleb128 0xe
 1185 0228 85020000 		.4byte	.LASF34
 1186 022c 01       		.byte	0x1
 1187 022d D404     		.2byte	0x4d4
 1188 022f 00000000 		.4byte	.LFB11
 1189 0233 58000000 		.4byte	.LFE11-.LFB11
 1190 0237 01       		.uleb128 0x1
 1191 0238 9C       		.byte	0x9c
 1192 0239 6B020000 		.4byte	0x26b
 1193 023d 0D       		.uleb128 0xd
 1194 023e 99000000 		.4byte	.LASF32
 1195 0242 01       		.byte	0x1
 1196 0243 D404     		.2byte	0x4d4
 1197 0245 6B020000 		.4byte	0x26b
 1198 0249 02       		.uleb128 0x2
 1199 024a 91       		.byte	0x91
 1200 024b 6C       		.sleb128 -20
 1201 024c 0D       		.uleb128 0xd
 1202 024d 7A010000 		.4byte	.LASF35
 1203 0251 01       		.byte	0x1
 1204 0252 D404     		.2byte	0x4d4
 1205 0254 6B000000 		.4byte	0x6b
 1206 0258 02       		.uleb128 0x2
 1207 0259 91       		.byte	0x91
 1208 025a 6B       		.sleb128 -21
 1209 025b 0F       		.uleb128 0xf
 1210 025c 63030000 		.4byte	.LASF33
 1211 0260 01       		.byte	0x1
 1212 0261 D704     		.2byte	0x4d7
 1213 0263 6B000000 		.4byte	0x6b
 1214 0267 02       		.uleb128 0x2
 1215 0268 91       		.byte	0x91
 1216 0269 77       		.sleb128 -9
 1217 026a 00       		.byte	0
 1218 026b 10       		.uleb128 0x10
 1219 026c 04       		.byte	0x4
 1220 026d 71020000 		.4byte	0x271
 1221 0271 11       		.uleb128 0x11
 1222 0272 6B000000 		.4byte	0x6b
 1223 0276 0E       		.uleb128 0xe
 1224 0277 65020000 		.4byte	.LASF36
 1225 027b 01       		.byte	0x1
 1226 027c F904     		.2byte	0x4f9
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 51


 1227 027e 00000000 		.4byte	.LFB12
 1228 0282 34000000 		.4byte	.LFE12-.LFB12
 1229 0286 01       		.uleb128 0x1
 1230 0287 9C       		.byte	0x9c
 1231 0288 9C020000 		.4byte	0x29c
 1232 028c 0D       		.uleb128 0xd
 1233 028d A4020000 		.4byte	.LASF27
 1234 0291 01       		.byte	0x1
 1235 0292 F904     		.2byte	0x4f9
 1236 0294 6B000000 		.4byte	0x6b
 1237 0298 02       		.uleb128 0x2
 1238 0299 91       		.byte	0x91
 1239 029a 77       		.sleb128 -9
 1240 029b 00       		.byte	0
 1241 029c 12       		.uleb128 0x12
 1242 029d DE010000 		.4byte	.LASF48
 1243 02a1 01       		.byte	0x1
 1244 02a2 1E05     		.2byte	0x51e
 1245 02a4 6B000000 		.4byte	0x6b
 1246 02a8 00000000 		.4byte	.LFB13
 1247 02ac 48000000 		.4byte	.LFE13-.LFB13
 1248 02b0 01       		.uleb128 0x1
 1249 02b1 9C       		.byte	0x9c
 1250 02b2 C6020000 		.4byte	0x2c6
 1251 02b6 0F       		.uleb128 0xf
 1252 02b7 5E030000 		.4byte	.LASF37
 1253 02bb 01       		.byte	0x1
 1254 02bc 2105     		.2byte	0x521
 1255 02be 6B000000 		.4byte	0x6b
 1256 02c2 02       		.uleb128 0x2
 1257 02c3 91       		.byte	0x91
 1258 02c4 77       		.sleb128 -9
 1259 02c5 00       		.byte	0
 1260 02c6 0E       		.uleb128 0xe
 1261 02c7 D9020000 		.4byte	.LASF38
 1262 02cb 01       		.byte	0x1
 1263 02cc 7405     		.2byte	0x574
 1264 02ce 00000000 		.4byte	.LFB14
 1265 02d2 44000000 		.4byte	.LFE14-.LFB14
 1266 02d6 01       		.uleb128 0x1
 1267 02d7 9C       		.byte	0x9c
 1268 02d8 EC020000 		.4byte	0x2ec
 1269 02dc 0F       		.uleb128 0xf
 1270 02dd 84010000 		.4byte	.LASF21
 1271 02e1 01       		.byte	0x1
 1272 02e2 7605     		.2byte	0x576
 1273 02e4 6B000000 		.4byte	0x6b
 1274 02e8 02       		.uleb128 0x2
 1275 02e9 91       		.byte	0x91
 1276 02ea 6F       		.sleb128 -17
 1277 02eb 00       		.byte	0
 1278 02ec 0C       		.uleb128 0xc
 1279 02ed 74020000 		.4byte	.LASF39
 1280 02f1 01       		.byte	0x1
 1281 02f2 CD05     		.2byte	0x5cd
 1282 02f4 00000000 		.4byte	.LFB15
 1283 02f8 B8000000 		.4byte	.LFE15-.LFB15
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 52


 1284 02fc 01       		.uleb128 0x1
 1285 02fd 9C       		.byte	0x9c
 1286 02fe 3D030000 		.4byte	0x33d
 1287 0302 0D       		.uleb128 0xd
 1288 0303 BE020000 		.4byte	.LASF40
 1289 0307 01       		.byte	0x1
 1290 0308 CD05     		.2byte	0x5cd
 1291 030a 6B000000 		.4byte	0x6b
 1292 030e 02       		.uleb128 0x2
 1293 030f 91       		.byte	0x91
 1294 0310 6F       		.sleb128 -17
 1295 0311 13       		.uleb128 0x13
 1296 0312 14000000 		.4byte	.LBB2
 1297 0316 88000000 		.4byte	.LBE2-.LBB2
 1298 031a 0F       		.uleb128 0xf
 1299 031b 52000000 		.4byte	.LASF41
 1300 031f 01       		.byte	0x1
 1301 0320 D505     		.2byte	0x5d5
 1302 0322 6B000000 		.4byte	0x6b
 1303 0326 02       		.uleb128 0x2
 1304 0327 91       		.byte	0x91
 1305 0328 77       		.sleb128 -9
 1306 0329 0F       		.uleb128 0xf
 1307 032a AF020000 		.4byte	.LASF42
 1308 032e 01       		.byte	0x1
 1309 032f FB05     		.2byte	0x5fb
 1310 0331 6B000000 		.4byte	0x6b
 1311 0335 05       		.uleb128 0x5
 1312 0336 03       		.byte	0x3
 1313 0337 01000000 		.4byte	tx_period.4771
 1314 033b 00       		.byte	0
 1315 033c 00       		.byte	0
 1316 033d 0C       		.uleb128 0xc
 1317 033e 6D000000 		.4byte	.LASF43
 1318 0342 01       		.byte	0x1
 1319 0343 4606     		.2byte	0x646
 1320 0345 00000000 		.4byte	.LFB16
 1321 0349 12000000 		.4byte	.LFE16-.LFB16
 1322 034d 01       		.uleb128 0x1
 1323 034e 9C       		.byte	0x9c
 1324 034f 63030000 		.4byte	0x363
 1325 0353 0D       		.uleb128 0xd
 1326 0354 22010000 		.4byte	.LASF44
 1327 0358 01       		.byte	0x1
 1328 0359 4606     		.2byte	0x646
 1329 035b 6B000000 		.4byte	0x6b
 1330 035f 02       		.uleb128 0x2
 1331 0360 91       		.byte	0x91
 1332 0361 77       		.sleb128 -9
 1333 0362 00       		.byte	0
 1334 0363 14       		.uleb128 0x14
 1335 0364 43000000 		.4byte	.LASF49
 1336 0368 01       		.byte	0x1
 1337 0369 1C       		.byte	0x1c
 1338 036a 6B000000 		.4byte	0x6b
 1339 036e 05       		.uleb128 0x5
 1340 036f 03       		.byte	0x3
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 53


 1341 0370 00000000 		.4byte	UART_1_initVar
 1342 0374 00       		.byte	0
 1343              		.section	.debug_abbrev,"",%progbits
 1344              	.Ldebug_abbrev0:
 1345 0000 01       		.uleb128 0x1
 1346 0001 11       		.uleb128 0x11
 1347 0002 01       		.byte	0x1
 1348 0003 25       		.uleb128 0x25
 1349 0004 0E       		.uleb128 0xe
 1350 0005 13       		.uleb128 0x13
 1351 0006 0B       		.uleb128 0xb
 1352 0007 03       		.uleb128 0x3
 1353 0008 0E       		.uleb128 0xe
 1354 0009 1B       		.uleb128 0x1b
 1355 000a 0E       		.uleb128 0xe
 1356 000b 55       		.uleb128 0x55
 1357 000c 17       		.uleb128 0x17
 1358 000d 11       		.uleb128 0x11
 1359 000e 01       		.uleb128 0x1
 1360 000f 10       		.uleb128 0x10
 1361 0010 17       		.uleb128 0x17
 1362 0011 00       		.byte	0
 1363 0012 00       		.byte	0
 1364 0013 02       		.uleb128 0x2
 1365 0014 24       		.uleb128 0x24
 1366 0015 00       		.byte	0
 1367 0016 0B       		.uleb128 0xb
 1368 0017 0B       		.uleb128 0xb
 1369 0018 3E       		.uleb128 0x3e
 1370 0019 0B       		.uleb128 0xb
 1371 001a 03       		.uleb128 0x3
 1372 001b 0E       		.uleb128 0xe
 1373 001c 00       		.byte	0
 1374 001d 00       		.byte	0
 1375 001e 03       		.uleb128 0x3
 1376 001f 24       		.uleb128 0x24
 1377 0020 00       		.byte	0
 1378 0021 0B       		.uleb128 0xb
 1379 0022 0B       		.uleb128 0xb
 1380 0023 3E       		.uleb128 0x3e
 1381 0024 0B       		.uleb128 0xb
 1382 0025 03       		.uleb128 0x3
 1383 0026 08       		.uleb128 0x8
 1384 0027 00       		.byte	0
 1385 0028 00       		.byte	0
 1386 0029 04       		.uleb128 0x4
 1387 002a 16       		.uleb128 0x16
 1388 002b 00       		.byte	0
 1389 002c 03       		.uleb128 0x3
 1390 002d 0E       		.uleb128 0xe
 1391 002e 3A       		.uleb128 0x3a
 1392 002f 0B       		.uleb128 0xb
 1393 0030 3B       		.uleb128 0x3b
 1394 0031 0B       		.uleb128 0xb
 1395 0032 49       		.uleb128 0x49
 1396 0033 13       		.uleb128 0x13
 1397 0034 00       		.byte	0
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 54


 1398 0035 00       		.byte	0
 1399 0036 05       		.uleb128 0x5
 1400 0037 16       		.uleb128 0x16
 1401 0038 00       		.byte	0
 1402 0039 03       		.uleb128 0x3
 1403 003a 0E       		.uleb128 0xe
 1404 003b 3A       		.uleb128 0x3a
 1405 003c 0B       		.uleb128 0xb
 1406 003d 3B       		.uleb128 0x3b
 1407 003e 05       		.uleb128 0x5
 1408 003f 49       		.uleb128 0x49
 1409 0040 13       		.uleb128 0x13
 1410 0041 00       		.byte	0
 1411 0042 00       		.byte	0
 1412 0043 06       		.uleb128 0x6
 1413 0044 35       		.uleb128 0x35
 1414 0045 00       		.byte	0
 1415 0046 49       		.uleb128 0x49
 1416 0047 13       		.uleb128 0x13
 1417 0048 00       		.byte	0
 1418 0049 00       		.byte	0
 1419 004a 07       		.uleb128 0x7
 1420 004b 2E       		.uleb128 0x2e
 1421 004c 00       		.byte	0
 1422 004d 3F       		.uleb128 0x3f
 1423 004e 19       		.uleb128 0x19
 1424 004f 03       		.uleb128 0x3
 1425 0050 0E       		.uleb128 0xe
 1426 0051 3A       		.uleb128 0x3a
 1427 0052 0B       		.uleb128 0xb
 1428 0053 3B       		.uleb128 0x3b
 1429 0054 0B       		.uleb128 0xb
 1430 0055 27       		.uleb128 0x27
 1431 0056 19       		.uleb128 0x19
 1432 0057 11       		.uleb128 0x11
 1433 0058 01       		.uleb128 0x1
 1434 0059 12       		.uleb128 0x12
 1435 005a 06       		.uleb128 0x6
 1436 005b 40       		.uleb128 0x40
 1437 005c 18       		.uleb128 0x18
 1438 005d 9642     		.uleb128 0x2116
 1439 005f 19       		.uleb128 0x19
 1440 0060 00       		.byte	0
 1441 0061 00       		.byte	0
 1442 0062 08       		.uleb128 0x8
 1443 0063 2E       		.uleb128 0x2e
 1444 0064 00       		.byte	0
 1445 0065 3F       		.uleb128 0x3f
 1446 0066 19       		.uleb128 0x19
 1447 0067 03       		.uleb128 0x3
 1448 0068 0E       		.uleb128 0xe
 1449 0069 3A       		.uleb128 0x3a
 1450 006a 0B       		.uleb128 0xb
 1451 006b 3B       		.uleb128 0x3b
 1452 006c 0B       		.uleb128 0xb
 1453 006d 27       		.uleb128 0x27
 1454 006e 19       		.uleb128 0x19
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 55


 1455 006f 11       		.uleb128 0x11
 1456 0070 01       		.uleb128 0x1
 1457 0071 12       		.uleb128 0x12
 1458 0072 06       		.uleb128 0x6
 1459 0073 40       		.uleb128 0x40
 1460 0074 18       		.uleb128 0x18
 1461 0075 9742     		.uleb128 0x2117
 1462 0077 19       		.uleb128 0x19
 1463 0078 00       		.byte	0
 1464 0079 00       		.byte	0
 1465 007a 09       		.uleb128 0x9
 1466 007b 2E       		.uleb128 0x2e
 1467 007c 01       		.byte	0x1
 1468 007d 3F       		.uleb128 0x3f
 1469 007e 19       		.uleb128 0x19
 1470 007f 03       		.uleb128 0x3
 1471 0080 0E       		.uleb128 0xe
 1472 0081 3A       		.uleb128 0x3a
 1473 0082 0B       		.uleb128 0xb
 1474 0083 3B       		.uleb128 0x3b
 1475 0084 0B       		.uleb128 0xb
 1476 0085 27       		.uleb128 0x27
 1477 0086 19       		.uleb128 0x19
 1478 0087 11       		.uleb128 0x11
 1479 0088 01       		.uleb128 0x1
 1480 0089 12       		.uleb128 0x12
 1481 008a 06       		.uleb128 0x6
 1482 008b 40       		.uleb128 0x40
 1483 008c 18       		.uleb128 0x18
 1484 008d 9642     		.uleb128 0x2116
 1485 008f 19       		.uleb128 0x19
 1486 0090 01       		.uleb128 0x1
 1487 0091 13       		.uleb128 0x13
 1488 0092 00       		.byte	0
 1489 0093 00       		.byte	0
 1490 0094 0A       		.uleb128 0xa
 1491 0095 34       		.uleb128 0x34
 1492 0096 00       		.byte	0
 1493 0097 03       		.uleb128 0x3
 1494 0098 0E       		.uleb128 0xe
 1495 0099 3A       		.uleb128 0x3a
 1496 009a 0B       		.uleb128 0xb
 1497 009b 3B       		.uleb128 0x3b
 1498 009c 0B       		.uleb128 0xb
 1499 009d 49       		.uleb128 0x49
 1500 009e 13       		.uleb128 0x13
 1501 009f 02       		.uleb128 0x2
 1502 00a0 18       		.uleb128 0x18
 1503 00a1 00       		.byte	0
 1504 00a2 00       		.byte	0
 1505 00a3 0B       		.uleb128 0xb
 1506 00a4 2E       		.uleb128 0x2e
 1507 00a5 00       		.byte	0
 1508 00a6 3F       		.uleb128 0x3f
 1509 00a7 19       		.uleb128 0x19
 1510 00a8 03       		.uleb128 0x3
 1511 00a9 0E       		.uleb128 0xe
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 56


 1512 00aa 3A       		.uleb128 0x3a
 1513 00ab 0B       		.uleb128 0xb
 1514 00ac 3B       		.uleb128 0x3b
 1515 00ad 05       		.uleb128 0x5
 1516 00ae 27       		.uleb128 0x27
 1517 00af 19       		.uleb128 0x19
 1518 00b0 49       		.uleb128 0x49
 1519 00b1 13       		.uleb128 0x13
 1520 00b2 11       		.uleb128 0x11
 1521 00b3 01       		.uleb128 0x1
 1522 00b4 12       		.uleb128 0x12
 1523 00b5 06       		.uleb128 0x6
 1524 00b6 40       		.uleb128 0x40
 1525 00b7 18       		.uleb128 0x18
 1526 00b8 9742     		.uleb128 0x2117
 1527 00ba 19       		.uleb128 0x19
 1528 00bb 00       		.byte	0
 1529 00bc 00       		.byte	0
 1530 00bd 0C       		.uleb128 0xc
 1531 00be 2E       		.uleb128 0x2e
 1532 00bf 01       		.byte	0x1
 1533 00c0 3F       		.uleb128 0x3f
 1534 00c1 19       		.uleb128 0x19
 1535 00c2 03       		.uleb128 0x3
 1536 00c3 0E       		.uleb128 0xe
 1537 00c4 3A       		.uleb128 0x3a
 1538 00c5 0B       		.uleb128 0xb
 1539 00c6 3B       		.uleb128 0x3b
 1540 00c7 05       		.uleb128 0x5
 1541 00c8 27       		.uleb128 0x27
 1542 00c9 19       		.uleb128 0x19
 1543 00ca 11       		.uleb128 0x11
 1544 00cb 01       		.uleb128 0x1
 1545 00cc 12       		.uleb128 0x12
 1546 00cd 06       		.uleb128 0x6
 1547 00ce 40       		.uleb128 0x40
 1548 00cf 18       		.uleb128 0x18
 1549 00d0 9742     		.uleb128 0x2117
 1550 00d2 19       		.uleb128 0x19
 1551 00d3 01       		.uleb128 0x1
 1552 00d4 13       		.uleb128 0x13
 1553 00d5 00       		.byte	0
 1554 00d6 00       		.byte	0
 1555 00d7 0D       		.uleb128 0xd
 1556 00d8 05       		.uleb128 0x5
 1557 00d9 00       		.byte	0
 1558 00da 03       		.uleb128 0x3
 1559 00db 0E       		.uleb128 0xe
 1560 00dc 3A       		.uleb128 0x3a
 1561 00dd 0B       		.uleb128 0xb
 1562 00de 3B       		.uleb128 0x3b
 1563 00df 05       		.uleb128 0x5
 1564 00e0 49       		.uleb128 0x49
 1565 00e1 13       		.uleb128 0x13
 1566 00e2 02       		.uleb128 0x2
 1567 00e3 18       		.uleb128 0x18
 1568 00e4 00       		.byte	0
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 57


 1569 00e5 00       		.byte	0
 1570 00e6 0E       		.uleb128 0xe
 1571 00e7 2E       		.uleb128 0x2e
 1572 00e8 01       		.byte	0x1
 1573 00e9 3F       		.uleb128 0x3f
 1574 00ea 19       		.uleb128 0x19
 1575 00eb 03       		.uleb128 0x3
 1576 00ec 0E       		.uleb128 0xe
 1577 00ed 3A       		.uleb128 0x3a
 1578 00ee 0B       		.uleb128 0xb
 1579 00ef 3B       		.uleb128 0x3b
 1580 00f0 05       		.uleb128 0x5
 1581 00f1 27       		.uleb128 0x27
 1582 00f2 19       		.uleb128 0x19
 1583 00f3 11       		.uleb128 0x11
 1584 00f4 01       		.uleb128 0x1
 1585 00f5 12       		.uleb128 0x12
 1586 00f6 06       		.uleb128 0x6
 1587 00f7 40       		.uleb128 0x40
 1588 00f8 18       		.uleb128 0x18
 1589 00f9 9642     		.uleb128 0x2116
 1590 00fb 19       		.uleb128 0x19
 1591 00fc 01       		.uleb128 0x1
 1592 00fd 13       		.uleb128 0x13
 1593 00fe 00       		.byte	0
 1594 00ff 00       		.byte	0
 1595 0100 0F       		.uleb128 0xf
 1596 0101 34       		.uleb128 0x34
 1597 0102 00       		.byte	0
 1598 0103 03       		.uleb128 0x3
 1599 0104 0E       		.uleb128 0xe
 1600 0105 3A       		.uleb128 0x3a
 1601 0106 0B       		.uleb128 0xb
 1602 0107 3B       		.uleb128 0x3b
 1603 0108 05       		.uleb128 0x5
 1604 0109 49       		.uleb128 0x49
 1605 010a 13       		.uleb128 0x13
 1606 010b 02       		.uleb128 0x2
 1607 010c 18       		.uleb128 0x18
 1608 010d 00       		.byte	0
 1609 010e 00       		.byte	0
 1610 010f 10       		.uleb128 0x10
 1611 0110 0F       		.uleb128 0xf
 1612 0111 00       		.byte	0
 1613 0112 0B       		.uleb128 0xb
 1614 0113 0B       		.uleb128 0xb
 1615 0114 49       		.uleb128 0x49
 1616 0115 13       		.uleb128 0x13
 1617 0116 00       		.byte	0
 1618 0117 00       		.byte	0
 1619 0118 11       		.uleb128 0x11
 1620 0119 26       		.uleb128 0x26
 1621 011a 00       		.byte	0
 1622 011b 49       		.uleb128 0x49
 1623 011c 13       		.uleb128 0x13
 1624 011d 00       		.byte	0
 1625 011e 00       		.byte	0
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 58


 1626 011f 12       		.uleb128 0x12
 1627 0120 2E       		.uleb128 0x2e
 1628 0121 01       		.byte	0x1
 1629 0122 3F       		.uleb128 0x3f
 1630 0123 19       		.uleb128 0x19
 1631 0124 03       		.uleb128 0x3
 1632 0125 0E       		.uleb128 0xe
 1633 0126 3A       		.uleb128 0x3a
 1634 0127 0B       		.uleb128 0xb
 1635 0128 3B       		.uleb128 0x3b
 1636 0129 05       		.uleb128 0x5
 1637 012a 27       		.uleb128 0x27
 1638 012b 19       		.uleb128 0x19
 1639 012c 49       		.uleb128 0x49
 1640 012d 13       		.uleb128 0x13
 1641 012e 11       		.uleb128 0x11
 1642 012f 01       		.uleb128 0x1
 1643 0130 12       		.uleb128 0x12
 1644 0131 06       		.uleb128 0x6
 1645 0132 40       		.uleb128 0x40
 1646 0133 18       		.uleb128 0x18
 1647 0134 9742     		.uleb128 0x2117
 1648 0136 19       		.uleb128 0x19
 1649 0137 01       		.uleb128 0x1
 1650 0138 13       		.uleb128 0x13
 1651 0139 00       		.byte	0
 1652 013a 00       		.byte	0
 1653 013b 13       		.uleb128 0x13
 1654 013c 0B       		.uleb128 0xb
 1655 013d 01       		.byte	0x1
 1656 013e 11       		.uleb128 0x11
 1657 013f 01       		.uleb128 0x1
 1658 0140 12       		.uleb128 0x12
 1659 0141 06       		.uleb128 0x6
 1660 0142 00       		.byte	0
 1661 0143 00       		.byte	0
 1662 0144 14       		.uleb128 0x14
 1663 0145 34       		.uleb128 0x34
 1664 0146 00       		.byte	0
 1665 0147 03       		.uleb128 0x3
 1666 0148 0E       		.uleb128 0xe
 1667 0149 3A       		.uleb128 0x3a
 1668 014a 0B       		.uleb128 0xb
 1669 014b 3B       		.uleb128 0x3b
 1670 014c 0B       		.uleb128 0xb
 1671 014d 49       		.uleb128 0x49
 1672 014e 13       		.uleb128 0x13
 1673 014f 3F       		.uleb128 0x3f
 1674 0150 19       		.uleb128 0x19
 1675 0151 02       		.uleb128 0x2
 1676 0152 18       		.uleb128 0x18
 1677 0153 00       		.byte	0
 1678 0154 00       		.byte	0
 1679 0155 00       		.byte	0
 1680              		.section	.debug_aranges,"",%progbits
 1681 0000 9C000000 		.4byte	0x9c
 1682 0004 0200     		.2byte	0x2
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 59


 1683 0006 00000000 		.4byte	.Ldebug_info0
 1684 000a 04       		.byte	0x4
 1685 000b 00       		.byte	0
 1686 000c 0000     		.2byte	0
 1687 000e 0000     		.2byte	0
 1688 0010 00000000 		.4byte	.LFB0
 1689 0014 24000000 		.4byte	.LFE0-.LFB0
 1690 0018 00000000 		.4byte	.LFB1
 1691 001c 28000000 		.4byte	.LFE1-.LFB1
 1692 0020 00000000 		.4byte	.LFB2
 1693 0024 38000000 		.4byte	.LFE2-.LFB2
 1694 0028 00000000 		.4byte	.LFB3
 1695 002c 38000000 		.4byte	.LFE3-.LFB3
 1696 0030 00000000 		.4byte	.LFB4
 1697 0034 0C000000 		.4byte	.LFE4-.LFB4
 1698 0038 00000000 		.4byte	.LFB5
 1699 003c 12000000 		.4byte	.LFE5-.LFB5
 1700 0040 00000000 		.4byte	.LFB6
 1701 0044 20000000 		.4byte	.LFE6-.LFB6
 1702 0048 00000000 		.4byte	.LFB7
 1703 004c 2C000000 		.4byte	.LFE7-.LFB7
 1704 0050 00000000 		.4byte	.LFB8
 1705 0054 14000000 		.4byte	.LFE8-.LFB8
 1706 0058 00000000 		.4byte	.LFB9
 1707 005c 34000000 		.4byte	.LFE9-.LFB9
 1708 0060 00000000 		.4byte	.LFB10
 1709 0064 54000000 		.4byte	.LFE10-.LFB10
 1710 0068 00000000 		.4byte	.LFB11
 1711 006c 58000000 		.4byte	.LFE11-.LFB11
 1712 0070 00000000 		.4byte	.LFB12
 1713 0074 34000000 		.4byte	.LFE12-.LFB12
 1714 0078 00000000 		.4byte	.LFB13
 1715 007c 48000000 		.4byte	.LFE13-.LFB13
 1716 0080 00000000 		.4byte	.LFB14
 1717 0084 44000000 		.4byte	.LFE14-.LFB14
 1718 0088 00000000 		.4byte	.LFB15
 1719 008c B8000000 		.4byte	.LFE15-.LFB15
 1720 0090 00000000 		.4byte	.LFB16
 1721 0094 12000000 		.4byte	.LFE16-.LFB16
 1722 0098 00000000 		.4byte	0
 1723 009c 00000000 		.4byte	0
 1724              		.section	.debug_ranges,"",%progbits
 1725              	.Ldebug_ranges0:
 1726 0000 00000000 		.4byte	.LFB0
 1727 0004 24000000 		.4byte	.LFE0
 1728 0008 00000000 		.4byte	.LFB1
 1729 000c 28000000 		.4byte	.LFE1
 1730 0010 00000000 		.4byte	.LFB2
 1731 0014 38000000 		.4byte	.LFE2
 1732 0018 00000000 		.4byte	.LFB3
 1733 001c 38000000 		.4byte	.LFE3
 1734 0020 00000000 		.4byte	.LFB4
 1735 0024 0C000000 		.4byte	.LFE4
 1736 0028 00000000 		.4byte	.LFB5
 1737 002c 12000000 		.4byte	.LFE5
 1738 0030 00000000 		.4byte	.LFB6
 1739 0034 20000000 		.4byte	.LFE6
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 60


 1740 0038 00000000 		.4byte	.LFB7
 1741 003c 2C000000 		.4byte	.LFE7
 1742 0040 00000000 		.4byte	.LFB8
 1743 0044 14000000 		.4byte	.LFE8
 1744 0048 00000000 		.4byte	.LFB9
 1745 004c 34000000 		.4byte	.LFE9
 1746 0050 00000000 		.4byte	.LFB10
 1747 0054 54000000 		.4byte	.LFE10
 1748 0058 00000000 		.4byte	.LFB11
 1749 005c 58000000 		.4byte	.LFE11
 1750 0060 00000000 		.4byte	.LFB12
 1751 0064 34000000 		.4byte	.LFE12
 1752 0068 00000000 		.4byte	.LFB13
 1753 006c 48000000 		.4byte	.LFE13
 1754 0070 00000000 		.4byte	.LFB14
 1755 0074 44000000 		.4byte	.LFE14
 1756 0078 00000000 		.4byte	.LFB15
 1757 007c B8000000 		.4byte	.LFE15
 1758 0080 00000000 		.4byte	.LFB16
 1759 0084 12000000 		.4byte	.LFE16
 1760 0088 00000000 		.4byte	0
 1761 008c 00000000 		.4byte	0
 1762              		.section	.debug_line,"",%progbits
 1763              	.Ldebug_line0:
 1764 0000 01020000 		.section	.debug_str,"MS",%progbits,1
 1764      02004500 
 1764      00000201 
 1764      FB0E0D00 
 1764      01010101 
 1765              	.LASF6:
 1766 0000 6C6F6E67 		.ascii	"long long int\000"
 1766      206C6F6E 
 1766      6720696E 
 1766      7400
 1767              	.LASF18:
 1768 000e 55415254 		.ascii	"UART_1_Init\000"
 1768      5F315F49 
 1768      6E697400 
 1769              	.LASF17:
 1770 001a 55415254 		.ascii	"UART_1_Start\000"
 1770      5F315F53 
 1770      74617274 
 1770      00
 1771              	.LASF22:
 1772 0027 55415254 		.ascii	"UART_1_WriteControlRegister\000"
 1772      5F315F57 
 1772      72697465 
 1772      436F6E74 
 1772      726F6C52 
 1773              	.LASF49:
 1774 0043 55415254 		.ascii	"UART_1_initVar\000"
 1774      5F315F69 
 1774      6E697456 
 1774      617200
 1775              	.LASF41:
 1776 0052 746D7053 		.ascii	"tmpStat\000"
 1776      74617400 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 61


 1777              	.LASF3:
 1778 005a 73686F72 		.ascii	"short unsigned int\000"
 1778      7420756E 
 1778      7369676E 
 1778      65642069 
 1778      6E7400
 1779              	.LASF43:
 1780 006d 55415254 		.ascii	"UART_1_SetTxAddressMode\000"
 1780      5F315F53 
 1780      65745478 
 1780      41646472 
 1780      6573734D 
 1781              	.LASF29:
 1782 0085 55415254 		.ascii	"UART_1_ReadTxStatus\000"
 1782      5F315F52 
 1782      65616454 
 1782      78537461 
 1782      74757300 
 1783              	.LASF32:
 1784 0099 73747269 		.ascii	"string\000"
 1784      6E6700
 1785              	.LASF11:
 1786 00a0 666C6F61 		.ascii	"float\000"
 1786      7400
 1787              	.LASF45:
 1788 00a6 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 1788      4320342E 
 1788      382E3420 
 1788      32303134 
 1788      30353236 
 1789 00d9 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m0 -mthumb -g -O"
 1789      20726576 
 1789      6973696F 
 1789      6E203231 
 1789      31333538 
 1790 010c 30202D66 		.ascii	"0 -ffunction-sections\000"
 1790      66756E63 
 1790      74696F6E 
 1790      2D736563 
 1790      74696F6E 
 1791              	.LASF44:
 1792 0122 61646472 		.ascii	"addressMode\000"
 1792      6573734D 
 1792      6F646500 
 1793              	.LASF15:
 1794 012e 72656738 		.ascii	"reg8\000"
 1794      00
 1795              	.LASF28:
 1796 0133 55415254 		.ascii	"UART_1_ReadControlRegister\000"
 1796      5F315F52 
 1796      65616443 
 1796      6F6E7472 
 1796      6F6C5265 
 1797              	.LASF20:
 1798 014e 55415254 		.ascii	"UART_1_Stop\000"
 1798      5F315F53 
 1798      746F7000 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 62


 1799              	.LASF5:
 1800 015a 6C6F6E67 		.ascii	"long unsigned int\000"
 1800      20756E73 
 1800      69676E65 
 1800      6420696E 
 1800      7400
 1801              	.LASF9:
 1802 016c 75696E74 		.ascii	"uint8\000"
 1802      3800
 1803              	.LASF24:
 1804 0172 636F6E74 		.ascii	"control\000"
 1804      726F6C00 
 1805              	.LASF35:
 1806 017a 62797465 		.ascii	"byteCount\000"
 1806      436F756E 
 1806      7400
 1807              	.LASF21:
 1808 0184 656E6162 		.ascii	"enableInterrupts\000"
 1808      6C65496E 
 1808      74657272 
 1808      75707473 
 1808      00
 1809              	.LASF1:
 1810 0195 756E7369 		.ascii	"unsigned char\000"
 1810      676E6564 
 1810      20636861 
 1810      7200
 1811              	.LASF12:
 1812 01a3 646F7562 		.ascii	"double\000"
 1812      6C6500
 1813              	.LASF25:
 1814 01aa 696E7453 		.ascii	"intSrc\000"
 1814      726300
 1815              	.LASF2:
 1816 01b1 73686F72 		.ascii	"short int\000"
 1816      7420696E 
 1816      7400
 1817              	.LASF10:
 1818 01bb 75696E74 		.ascii	"uint16\000"
 1818      313600
 1819              	.LASF30:
 1820 01c2 55415254 		.ascii	"UART_1_PutChar\000"
 1820      5F315F50 
 1820      75744368 
 1820      617200
 1821              	.LASF8:
 1822 01d1 756E7369 		.ascii	"unsigned int\000"
 1822      676E6564 
 1822      20696E74 
 1822      00
 1823              	.LASF48:
 1824 01de 55415254 		.ascii	"UART_1_GetTxBufferSize\000"
 1824      5F315F47 
 1824      65745478 
 1824      42756666 
 1824      65725369 
 1825              	.LASF7:
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 63


 1826 01f5 6C6F6E67 		.ascii	"long long unsigned int\000"
 1826      206C6F6E 
 1826      6720756E 
 1826      7369676E 
 1826      65642069 
 1827              	.LASF47:
 1828 020c 433A5C55 		.ascii	"C:\\Users\\Samuel\\Documents\\GitHub\\Arm\\Dynamixe"
 1828      73657273 
 1828      5C53616D 
 1828      75656C5C 
 1828      446F6375 
 1829 0239 6C5F5365 		.ascii	"l_Servo_Driver\\Dynamixel_Servo_Driver.cydsn\000"
 1829      72766F5F 
 1829      44726976 
 1829      65725C44 
 1829      796E616D 
 1830              	.LASF36:
 1831 0265 55415254 		.ascii	"UART_1_PutCRLF\000"
 1831      5F315F50 
 1831      75744352 
 1831      4C4600
 1832              	.LASF39:
 1833 0274 55415254 		.ascii	"UART_1_SendBreak\000"
 1833      5F315F53 
 1833      656E6442 
 1833      7265616B 
 1833      00
 1834              	.LASF34:
 1835 0285 55415254 		.ascii	"UART_1_PutArray\000"
 1835      5F315F50 
 1835      75744172 
 1835      72617900 
 1836              	.LASF16:
 1837 0295 73697A65 		.ascii	"sizetype\000"
 1837      74797065 
 1837      00
 1838              	.LASF13:
 1839 029e 63686172 		.ascii	"char8\000"
 1839      3800
 1840              	.LASF27:
 1841 02a4 74784461 		.ascii	"txDataByte\000"
 1841      74614279 
 1841      746500
 1842              	.LASF42:
 1843 02af 74785F70 		.ascii	"tx_period\000"
 1843      6572696F 
 1843      6400
 1844              	.LASF14:
 1845 02b9 63686172 		.ascii	"char\000"
 1845      00
 1846              	.LASF40:
 1847 02be 7265744D 		.ascii	"retMode\000"
 1847      6F646500 
 1848              	.LASF26:
 1849 02c6 55415254 		.ascii	"UART_1_WriteTxData\000"
 1849      5F315F57 
 1849      72697465 
ARM GAS  C:\Users\Samuel\AppData\Local\Temp\ccocu4vY.s 			page 64


 1849      54784461 
 1849      746100
 1850              	.LASF38:
 1851 02d9 55415254 		.ascii	"UART_1_ClearTxBuffer\000"
 1851      5F315F43 
 1851      6C656172 
 1851      54784275 
 1851      66666572 
 1852              	.LASF4:
 1853 02ee 6C6F6E67 		.ascii	"long int\000"
 1853      20696E74 
 1853      00
 1854              	.LASF23:
 1855 02f7 55415254 		.ascii	"UART_1_SetTxInterruptMode\000"
 1855      5F315F53 
 1855      65745478 
 1855      496E7465 
 1855      72727570 
 1856              	.LASF19:
 1857 0311 55415254 		.ascii	"UART_1_Enable\000"
 1857      5F315F45 
 1857      6E61626C 
 1857      6500
 1858              	.LASF46:
 1859 031f 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\UART_1.c\000"
 1859      6E657261 
 1859      7465645F 
 1859      536F7572 
 1859      63655C50 
 1860              	.LASF0:
 1861 0341 7369676E 		.ascii	"signed char\000"
 1861      65642063 
 1861      68617200 
 1862              	.LASF31:
 1863 034d 55415254 		.ascii	"UART_1_PutString\000"
 1863      5F315F50 
 1863      75745374 
 1863      72696E67 
 1863      00
 1864              	.LASF37:
 1865 035e 73697A65 		.ascii	"size\000"
 1865      00
 1866              	.LASF33:
 1867 0363 6275665F 		.ascii	"buf_index\000"
 1867      696E6465 
 1867      7800
 1868              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
